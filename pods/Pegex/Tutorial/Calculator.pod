=pod

=for comment
DO NOT EDIT. This Pod was generated by Swim v0.1.38.
See http://github.com/ingydotnet/swim-pm#readme

=encoding utf8

=head1 Pegex Tutorial Calculator

A Pegex 计算器

当你看所有的解析器的时候，都会告诉你一个例子，怎么样用它来写一个计算器来做各种表达式。

=over

=item * L<http://en.wikipedia.org/wiki/Operator-precedence_parser>

=item * L<http://eli.thegreenplace.net/2010/01/02/top-down-operator-precedence-parsing/>

=item * L<http://www.hokstad.com/operator-precedence-parser.html>

=item * L<http://www.perlmonks.org/?node_id=554516>

=back

这个教程就是 Pegex 的版本。 Pegex 在这个例子的目标中包括二个表达式解析/计算的算法程序:

=over

=item * L<https://github.com/ingydotnet/pegex-pm/blob/master/examples/calculator1.pl>

=item * L<https://github.com/ingydotnet/pegex-pm/blob/master/examples/calculator2.pl>

=back

这二个其实是相同的东西，只是实现解析的方式不同。我们会在这二个中详细介绍。
这会让你看到　Pegex 如何优美的处理操作符优先级的解析过程。

=head1 The Problem

优先级解析是非常有意思的，因为你必须决定那个操作符的优先级更加高，不同的优先级
会有不同左结合性或者右结合性。

想想下面这个方程式:

    1 - 2 ^ 3 ^ 4 + 5 * 6 / 7

标准的优先级和结合性规则会是如下：

    (1 - (2 ^ (3 ^ 4)) + ((5 * 6) / 7))

我们计算时要产生相同的结果。这意味着我们要解析数字，5 个操作符, 圆括号和空白分隔符。

这是一个计算器程序运行的例子:

    > perl examples/calculator1.pl
    Enter an equation: 1+2*3
    1+2*3 = 7
    Enter an equation: (1 + 2) * 3
    (1 + 2) * 3 = 9
    Enter an equation:

=head1 The Solutions

大多数的网上找到的你能读到的解决方案，在解析之前，大多会按步骤的做词法分析和标记分析。

Pegex 总是直接解析输入的流, 通过使用正则表达式找到其中的标记 "tokens".　解析一个操作，这有几个好处。

但是如果我们有操作的优先级规则在这怎么办? 这我们有二种不同的方法。

=head2 calculator1.pl - Operator Precedence Climbing

我们的第一个例子计算器使用什么被称 Operator Precedence Climbing method. 
See: L<http://en.wikipedia.org/wiki/Operator- precedence_parser#Precedence_climbing_method>.

This is basically a clever technique of specifying our grammar rules such that they imply precedence. Here's the pegex grammar from the code:

    expr: add_sub
    add_sub: mul_div+ % /- ([ PLUS DASH ]) -/
    mul_div: exp+ % /- ([ STAR SLASH ]) -/
    exp: token+ % /- CARET -/
    token: /- LPAREN -/ expr /- RPAREN -/ | number
    number: /- ( DASH? DIGIT+ ) -/

It's a little bit wonky but it works. It says that any expression is an
addI<subtract and that an add>subtract is really a multiply/divide etc.
Finally after the last operator comes the number token and the parens.

这有点不好，就是在 PCM 中有个大的问题，就是当越来越多的操作符的时候，效率越来越低。
为了找到每个数字，它必须找完到整个树.

但他的代码非常少就能工作。
But it works and the code is minimal. The receiver class gets the numbers in
the correct order, immediately evaluates the answer and returns the answer for
each level. Whatever the return value of the final operation is, becomes the
result of the parse. Here's the receiver class:

    {
        package Calculator;
        use base 'Pegex::Tree';

        sub got_add_sub {
            my ($self, $list) = @_;
            $self->flatten($list);
            while (@$list > 1) {
                my ($a, $op, $b) = splice(@$list, 0, 3);
                unshift @$list, ($op eq '+') ? ($a + $b) : ($a - $b);
            }
            @$list;
        }

        sub got_mul_div {
            my ($self, $list) = @_;
            $self->flatten($list);
            while (@$list > 1) {
                my ($a, $op, $b) = splice(@$list, 0, 3);
                unshift @$list, ($op eq '*') ? ($a * $b) : ($a / $b);
            }
            @$list;
        }

        sub got_exp {
            my ($self, $list) = @_;
            $self->flatten($list);
            while (@$list > 1) {
                my ($a, $b) = splice(@$list, -2, 2);
                push @$list, $a ** $b;
            }
            @$list;
        }
    }

As you can see, it has an action method for each level or precedence. It loops
over the expression, evaluating it. Whether it loops from left to right or
right to left depends on the associativity that we want to use.

Our runner code looks like this:

    while (1) {
        print "\nEnter an equation: ";
        my $input = <>;
        chomp $input;
        last unless length $input;
        calc($input);
    }

    sub calc {
        my $expr = shift;
        my $calculator = pegex($grammar, 'Calculator');
        my $result = eval { $calculator->parse($expr) };
        print $@ || "$expr = $result\n";
    }

And that's the whole thing. We have a working calculator as specced!

However the real point of this is to explore good parsing techniques, and the
PCM leaves us wanting to try something more efficient. Let's try another
approach...

=head2 calculator2.pl - Shunting Yard Algorithm

An age old way of parsing expressions is to somehow get the numbers and
operators into an RPN (Reverse Polish Notation) stack, which is each operand
follow by its operator. Once in that form, precedence and associativity are
accounted for.

For example:

    1 / 2 - ( -3 * 4 )

becomes:

    1, 2, /, -3, 4, *, -

To evaluate an RPN you pop off an operator and then attempt to pop off and
operand. If the operand is another operator you recurse. When you have 2
operands you do the operation and put the result back on the stack. When there
is only 1 element on the stack, you are done. That's your result.

Let's look at our new grammar in C<calculator2.pl>:

    expr: operand ( operator operand )*
    operator: /- ([ PLUS DASH STAR SLASH CARET ]) -/
    operand: num | /- LPAREN -/ expr /- RPAREN -/
    num: /- ( DASH? DIGIT+ ) -/

This is much easier to understand. We are just parsing out the tokens. In a
(very real) sense, we are using Pegex as a lexer.

Now let's look at the receiver class:

    {
        package Calculator;
        use base 'Pegex::Tree', 'Precedence';

        my $operator_precedence_table = {
            '+' => {p => 1, a => 'l'},
            '-' => {p => 1, a => 'l'},
            '*' => {p => 2, a => 'l'},
            '/' => {p => 2, a => 'l'},
            '^' => {p => 3, a => 'r'},
        };

        sub got_expr {
            my ($self, $expr) = @_;
            $self->precedence_rpn($expr, $operator_precedence_table);
        }
    }

This is also much simpler. There's only one method. What's going on? Well the
secret is that I put the code to turn the tokens into RPN in a separate base
class called L<examples/lib/Precedence.pm>.

This is an implementation of Edsger Dijkstra's famous Shunting-yard Algorithm
from 1961! It's only 20 lines of Perl. I won't include it inline here, but
have a look at it for yourself. L<https://github.com/ingydotnet/pegex-
pm/blob/master/examples/lib/Precedence.pm>

The Shunting-yard algorithm simply takes a list of expression tokens and
transforms them into an RPN stack. It uses information from a
precedence/associativity table like the one above.

Unlike L<calculator1.pl> where we evaluated as we parsed, L<calculator2.pl>
creates an RPN which is akin to an AST. In other words, it's more like
something an actually language compiler would do.

But we are writing a calculator and we still need to evaluate this pupy. I
changed the runner code to look like this:

    sub calc {
        my $expr = shift;
        my $calculator = pegex($grammar, 'Calculator');
        my $rpn = eval { $calculator->parse($expr) };
        my $result = RPN::evaluate($rpn);
        print $@ || "$expr = $result\n";
    }

As you can see I also moved the evaluator code into a separate/reusable
module: L<examples/lib/RPN.pm>. This is another 30 lines of Perl. Please take
a look at it. L<https://github.com/ingydotnet/pegex-
pm/blob/master/examples/lib/RPN.pm>

So overall, this second solution was a bit more code, but also feels more
solid on several levels.

=head1 Conclusion

Pegex strives to be the nicest and most reusable way to write new parsers.
Operator precedence parsers are a necessary part of parsing mathematical
expressions and computer languages. This tutorial showed you 2 ways to do it.
As the demands for Pegex grow, we may see even more ways to do it.

=cut
