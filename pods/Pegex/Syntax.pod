=pod

=for comment
DO NOT EDIT. This Pod was generated by Swim v0.1.38.
See http://github.com/ingydotnet/swim-pm#readme

=encoding utf8

=head1 Pegex Syntax

这个中讲的 "Pegex" 是指 Pegex 解析的框架或 Pegex Grammar Language Syntax 用于写 Pegex grammar 文件.

这个文档详细的讲了 Pegex Syntax.

Pegex 是自描述语言 (self-hosting). 这意味着 Pegex Language 语言是通过自己 Pegex Language 来定义和生成自己.
你可以看看: L<https://github.com/ingydotnet/pegex-pgx/blob/master/pegex.pgx>.

我鼓励你快速的看看这个. 一个 Pegex grammar 主要是由二部分组成: 元数据区 (meta section) 和规则区 (rule section).

这个元数据区只是包含 grammar 语法的 keyword/value 的元属性.  这用于显示 grammar 的名字和版本.

这实际的 Pegex grammar 的元数据区是规则 (rule). 这 grammar 首先的规则是如下:

    grammar: meta_section rule_section

在这，我们可以讲语法 B<grammar> 是一个元数据区 B<meta_section> 跟着一个规则区 B<rule_section>.

=head1 Meta Section

元数据区声明一个 grammar 文件的顶层就象:

    %pegexKeyword value

让我们看看 pegex.pgx 中的 grammar 的顶层:

    # This is the Pegex grammar for Pegex grammars!
    %grammar pegex
    %version 0.1.0

这定义了二个元值: C<grammar> 和 C<version>. 这分别给 grammar 指定了名字和版本.

你也许注意到首行是一个注释。注释是由 C<#> 开始直到行结束. 注释基本可以写在 grammar 任何地方。
包含它单独自己一行，或者声明之后，或者正则定义的后面, 这个我们后面能见到.

这个 Pegex 元数据区结束后就是 Pegex 规则区的开始 (这可以开始第一个 rule 定义).

=head1 Rule Section

Pegex grammar  剩余的是用于设置规则的名字, 每个规则是由规则名紧接着一个 ':',
在接着定义我们的规则, 在接着一个 ';' 或者定义新行.

这是在 pegex.pgx grammar 语法的一对规则.
Here are a couple rules from the pegex.pgx grammar. (These are the rules that start to define a rule!).

    rule_definition:
        rule_start
        rule_group
        ending

    rule_start: /
        ( rule_name )     # Capture the rule_name
        BLANK*
        COLON -
    /

规则定义了中缀表达式.

它们是被操作符分开的标记组成, 用括号来区分结合优先级, 有3个不同的标记和3个操作符.

Rule definitions are infix expressions. They consist of tokens separated by
operators, with parentheses to disambiguate binding precedence. There are 3
distinct tokens and 3 operators.

这有 3 种标记 (token) 类型: 规则引用 (rule-reference), 正则 (regex) 和错误信息 ( error-message ).  和 3 种操作 AND (' '), OR ('|') 和  ALT ('%', '%%').

这有个 Pegex grammar 解析 json：

    json: hash | array
    array: 
		/ LSQUARE / 
		( node* % / COMMA / ) 
	    ( / RSQUARE / | `missing ']'` )

这可以理解成: "json 是可以 hash 或者数组, 数组是 '[' 零或者多个节点由逗号分割, 或者一个 ']'， 如果没有 ']' 就是错误".

C<hash>, C<array> 和 C<node> 是规则的引用, 意味着它们指向引用到 grammar 语法中相同的规则名字, 这种是必须匹配到的命名规则. 
文本被 '/' 字符环绕的部分构成一个正则表达式. 本周围的反引号是错误消息.
Text surrounded by a pair of '/' chars forms a regex. 
Text surrounding by backticks is an error message.

C<LSQUARE>, C<RSQUARE> 和 C<COMMA> 也是规则引用. 规则也可以放到其它的正则表达式内. 这样大的正则表达式可以从较小的组装，从实现重用和提高可读性.
最后在 C<node> 后面有个 '*' 这个叫量词. 后面会说更多.

=head2 Rule References

规则引用是一些规则的名称, 通常放在括号内. 但这个括号是可选的. 一个正则表达式如果没有　C<< <> >>　时，规则的引用必须前面有空格.

    <sub_rule_name>
      sub_rule_name

当我们在外面使用正则时, 这个规则引用后面加以加多个前缀修饰符. 注意在这里不需要尖括号, 但有了会增加可读性.

    =rule  # Zero-width positive assertion (look-ahead)
    !rule  # Zero-width negative assertion (look-ahead)
    .rule  # 跳过 (ie: 解析但不捕获的子模式)
    -rule  # Flat (Flat 捕获成数组)
    +rule  # 可以捕获

(跳过和捕获的解释看 [Return Values].)

每一个规则引用, 也可以有多个后缀量词. 类似于正则的语法.
量词用于指定有多少次可以找到个这个匹配到的规则(引用).

    rule?      # optional
    rule*      # 0 or more times
    rule+      # 1 or more times
    <rule>8    # exactly 8 times
    <rule>2+   # 2 or more times
    <rule>2-3  # 2 or 3 times
    <rule>0-6  # 0 to 6 times

注意，如果你使用了数字的修饰符，你必须使用尖括号.

    rule8    # WRONG!  This would match rule "rule8".
    rule2+   # WRONG!  This would match rule "rule2", 1 or more times.
    rule2-3  # WRONG!  Pegex syntax error

有一组特殊的预定义 "L<Atoms|Pegex::Grammar::Atoms>" 这个是指的一些常用的正则的片段。 Atoms 存在于每个正则表达式中用于替换标点符号和字符。 
Atoms 增加了 grammar 文件的可读性，可以让你指定有一定指定的符号 (like slash or hash) 可以用于 Pegex 语法.

例如, 一个正则匹配注释, 象 '#' 开始的任何内容, 在 Pegex 中，你会这样写:

    comment: / HASH ANY* EOL /

相当于:

    comment: /#.*\r?\n/

Pegex 会给前面的编译成后面这个.

这还有一些 atom:

    DASH    # -
    PLUS    # +
    TILDE   # ~
    SLASH   # /
    HASH    # # (literal)
    QMARK   # ? (literal)
    STAR    # * (literal)
    LPAREN  # ( (literal)
    RPAREN  # ) (literal)
    WORD    # \w
    WS      # \s

完整的列表，请看 [Atoms source code|L<https://metacpan.org/source/Pegex::Grammar::Atoms>].

=head2 Regexes

在 Pegex 中调用一个正则表达式 "regex" 时，这个术语的 "regex" 是指的 Pegex 语法的引用，在实际使用的时候会编译成真实的正则.

一个正则表达式是一个放在斜杠内的字符串.

    /regex/

正则表达式的语法大多是 Perl, 但下列情况除外:

    # 规则通过尖括号引用到正则当中
    / ( <rule1> | 'non_rule' ) /  # "non_rule" is interpreted literally

    # 这个语法使用了 /x 的正则修饰符, 所以空格和注释是忽略的.
    / (
        rule1+   # Match rule1 one or more times
        |
        rule2
    ) /

    # Whitespace is declared with dash and plus.
    / - rule3 + /  # - 相当于 \s*, + 相当于 \s+, etc.

    # Any (?XX ) syntax can have the question mark removed
    / (: a | b ) /  # same as / (?: a | b ) /

=head2 Error Message

错误消息字符串是放在反引号内. 如果分析器获取语法错误，就会从中取出消息，它会抛出一个与该消息相差的解析错误。

    `error message`

=head2 Operators

Pegex 操作符的优先级是通过: ALT, AND, 和 OR.

AND 与 OR 是最常见的操作符. AND 是在没有操作符的时候生效. 像在这些规则中:

    r1: <a><b>
    r2: a b

上面这二个都是相同的. 它们的意思是规则 C<a> 并 (紧接着) C<b> 规则.

OR 意味着要匹配一个或者更多.

    r: a | b | c

上面匹配指定规则必须 C<a> OR C<b> OR C<c> 规则. 当任何一个匹配时, 其它的都会跳过.

ALT 这是一种在列表中指定分隔符的方法.

    r: a+ % b

主样会被匹配成:

    a
    aba
    ababa


C<%%> 是指定一个可选择的分隔符. 

    r: a+ %% b

这样会.

    a
    ab
    aba
    abab

ANY 运算符的优先级高于一切，类似于其他分析器。这些规则具有相同的结合优先性:

    r1: a b | c % d
    r2: (a b) | (c % d)

括号不仅用于指示绑定优先; 他们也可以创建可量化的组:

    r1: (a b)+ c

这会匹配: 

    abababac

=head1 Return Values

所有的返回值都是基于捕获组 C<$1/$2/$3/etc.> 的变量来解析正则的声明。 这导出的是一个深度树型结果给 Receiver 使用. 例如， L<Pegex::Tree>:   

    $1              # single capture group
    [ @+[1..$#+] ]  # multiple capture groups

当正则匹配到各种规则, 会给结果一步步存进数组，所以无论是多少个结果，只会返回一个内容. 例如:

    r: (a b)+ % +
    a: /( ALPHA+ )/
    b: /( DIGIT+ )( PLUS )/

    # input = foobar123+
    # output (using Pegex::Tree) = [
    #     'foobar', [ '123', '+' ]
    # ]
    #
    # input = foobar123+ boofar789+
    # output (using Pegex::Tree) = [
    #     [ 'foobar', [ '123', '+' ] ],
    #     [ 'boofar', [ '789', '+' ] ],
    # ]

=head2 Skipping

任何规则都能使用跳过修饰符 (DOT) 来实现对于规则结果的跳过. 主个的结果还是会处理，但是不会给值存到树中.( 这有点不同，这可以讲是传上一个 C<undef> 到结果当中).
这也会影响返回的值的数目, and thus, whether a value comes as an array:

    r: (a .b)+ % +
    a: /( ALPHA+ )/
    b: /( DIGIT+ )( PLUS )/

    # input = foobar123+ boofar789+
    # output (using Pegex::Tree) = [
    #     'foobar',
    #     'boofar',
    # ]

这个跳过的修饰符也可以用于组. (这是迄今为止唯一的组修饰符)

    r: .(a b)+ % +
    a: /( ALPHA+ )/
    b: /( DIGIT+ )( PLUS )/

    # output (using Pegex::Tree) = []

=head2 Wrapping

对于找到的结果，可以通过 L<Pegex::Tree::Wrap> 的 receiver 来打开. 这个东西会给将所有的匹配值包在一个和规则名一样的哈希中:

    { rule_A => $match }
    { rule_B => [ @matches ] }

注意这个可能会被  C<+/-> 的规则修饰符所硬性设置:

    -rule  # Flatten array captures
    +rule  # Always wrap (even if using Pegex::Tree)

这样在你的 receiver 对象中只需要简单的检查  C<gotrule>。 所以指定 C<got_*> 的接收的方法，就会重写这些设置， 在这个例子中 C<got_*>  会返回这个最终匹配的树的对象:

    +rule_A   # in this case, the + is useless here

    sub got_rule_A {
        my ($self, $matches_arrayref) = @_;
        return $matches_arrayref;
        # will be received as [ @matches ]
    }

你可以通过调用 C<gotrule> 方法来正确的处理这些参数:

    +rule_A   # now + is honored

    sub got_rule_A {
        my ($self, $matches_arrayref) = @_;
        return $self->gotrule($matches_arrayref);
        # will be received as { rule_A => [ @matches ] }
    }

=head1 See Also

=over

=item * L<Pegex::API>

=item * L<Pegex::Tutorial>

=item * L<Pegex::Resources>

=back

=cut
