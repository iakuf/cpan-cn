=pod

=for comment
DO NOT EDIT. This Pod was generated by Swim v0.1.38.
See http://github.com/ingydotnet/swim-pm#readme

=encoding utf8

=head1 Pegex Syntax

这个中讲的 "Pegex" 是指 Pegex 解析的框架或 Pegex Grammar Language Syntax 用于写 Pegex grammar 文件.

这个文档详细的讲了 Pegex Syntax.

Pegex 是 self-hosting 语言. 这意味着 Pegex Language 语言是通过自己 Pegex Language 来定义和生成自己.
你可以看看: L<https://github.com/ingydotnet/pegex-pgx/blob/master/pegex.pgx>.

我鼓励你快速的看看这个. 一个 Pegex grammar 主要是由二部分组成:  meta section 和 rule section.

这个 meta section 只是包含 keyword/value 的元属性的 grammar. 
这用于显示 grammar 的名字和版本.

这实际的 Pegex grammar 的元数据是 rule. 这 grammar 首先的 rule 规则是如下:

    grammar: meta_section rule_section

在这，我们可以讲 B<grammar> 是一个 B<meta_section> 跟着一个 B<rule_section>.

=head1 Meta Section

元数据区声明一个 grammar 文件的顶层就象:

    %pegexKeyword value

让我们看看 pegex.pgx 中的 grammar 的顶层:

    # This is the Pegex grammar for Pegex grammars!
    %grammar pegex
    %version 0.1.0

这定义了二个元值: C<grammar> 和 C<version>. 这分别给 grammar 指定了名字和版本.

你也许注意到首行是一个注释。注释是由 C<#> 开始直到行结束. 注释基本可以写在 grammar 任何地方。
包含它单独自己一行，或者声明之后，或者正则定义的后面, 这个我们后面能见到.

这个 Pegex 元数据区结束后就是 Pegex 规则区的开始 (这可以开始第一个 rule 定义).

=head1 Rule Section

Pegex grammar  剩余的是用于设置 rule 名字, 每个 rule 是一个 rule 名字紧接着一个 ':',
在接着是我们对规则的定义, 在接着一个 ';' 或者定义新行.

这是在 pegex.pgx 语法的一对规则.
Here are a couple rules from the pegex.pgx grammar. (These are the rules that
start to define a rule!).

    rule_definition:
        rule_start
        rule_group
        ending

    rule_start: /
        ( rule_name )     # Capture the rule_name
        BLANK*
        COLON -
    /

规则定义了中缀表达式.

它们是被操作符分开的标记组成, 用括号来区分结合优先级, 有3个不同的标记和3个操作符.

Rule definitions are infix expressions. They consist of tokens separated by
operators, with parentheses to disambiguate binding precedence. There are 3
distinct tokens and 3 operators.

这有 3 种标记 (token) 类型: 规则引用 (rule-reference), 正则 (regex) 和错误信息 ( error-message ).  和 3 种操作 AND (' '), OR ('|') 和  ALT ('%', '%%').

这有个 Pegex grammar 解析 json：

    json: hash | array
    array: / LSQUARE / ( node* % / COMMA / ) ( / RSQUARE / | `missing ']'` )

这可以理解成: "json 是可以 hash 或者数组, 数组是 '[' 零或者多个节点由逗号分割, 或者一个 ']'， 如果没有 ']' 就是错误".

C<hash>, C<array> 和 C<node> 是规则的引用, 意味着这是引用到相同名字的在 grammar 中的 rule 名, 这种是必须匹配到的定. 
文本被 '/' 字符环绕成一个正则.
C<hash>, C<array> and C<node> are rule references, meaning that they refer to
named rules within the grammar that must match at that point. Text surrounded
by a pair of '/' chars forms a regex. Text surrounding by backticks is an
error message.

C<LSQUARE>, C<RSQUARE> and C<COMMA> are also rule references. Rules may be
referred to inside of regexes, as long as they refer to regexes themselves. In
this way big regexes can be assembled from smaller ones, thus leading to reuse
and readability. Finally, the '*' after C<node> is called a "quntifier". More
about those later.

=head2 Rule References

规则引用是一个规则的名称, 通常放在括号内. 但这个括号是可选的. 一个正则表达式如果没有　C<< <> >>　时，规则的引用必须前面有空格.

    <sub_rule_name>
    sub_rule_name

When used outside a regex, a reference can have a number of prefix modifiers.  Note the the angle brackets are not required here, but add to readability.

    =rule  # Zero-width positive assertion (look-ahead)
    !rule  # Zero-width negative assertion (look-ahead)
    .rule  # Skip (ie: parse but don't capture a subpattern)
    -rule  # Flat (flatten the array captures)
    +rule  # Always wrap

(Skipping and wrapping are explained in [Return Values].)

A reference can also have a number of suffixed quantifiers. Similar to regular
expression syntax, a quantifier indicates how many times a rule (reference)
should match.

    rule?      # optional
    rule*      # 0 or more times
    rule+      # 1 or more times
    <rule>8    # exactly 8 times
    <rule>2+   # 2 or more times
    <rule>2-3  # 2 or 3 times
    <rule>0-6  # 0 to 6 times

Note that you must use angle brackets if you are using a numbered modifier:

    rule8    # WRONG!  This would match rule "rule8".
    rule2+   # WRONG!  This would match rule "rule2", 1 or more times.
    rule2-3  # WRONG!  Pegex syntax error

There is a special set of predefined "L<Atoms|Pegex::Grammar::Atoms>" that
refer to regular expression fragments. Atoms exist for every punctuation
character and for characters commonly found in regular expressions. Atoms
enchance readability in grammar texts, and allow special characters (like
slash or hash) to be used as Pegex syntax.

For example, a regex to match a comment might be '#' followed by anything,
followed by a newline. In Pegex, you would write:

    comment: / HASH ANY* EOL /

instead of:

    comment: /#.*\r?\n/

Pegex would compile the former into the latter.

Here are some atoms:

    DASH    # -
    PLUS    # +
    TILDE   # ~
    SLASH   # /
    HASH    # # (literal)
    QMARK   # ? (literal)
    STAR    # * (literal)
    LPAREN  # ( (literal)
    RPAREN  # ) (literal)
    WORD    # \w
    WS      # \s

The full list can be found in the [Atoms source
code|L<https://metacpan.org/source/Pegex::Grammar::Atoms].>

=head2 Regexes

In Pegex we call the syntax for a regular expression a "regex". ie When the
term "regex" is used, it is referring to Pegex syntax, and when the term
"regular expression" is used it refers to the actual regular expression that
the regex is compiled into.

A regex is a string inside forward slashes.

    /regex/

The regex syntax mostly follows Perl, with the following exceptions:

    # Any rules in angle brackets are referenced in the regex
    / ( <rule1> | 'non_rule' ) /  # "non_rule" is interpreted literally

    # The syntax implies a /x modifier, so whitespace and comments are
    # ignored.
    / (
        rule1+   # Match rule1 one or more times
        |
        rule2
    ) /

    # Whitespace is declared with dash and plus.
    / - rule3 + /  # - = \s*, + = \s+, etc.

    # Any (?XX ) syntax can have the question mark removed
    / (: a | b ) /  # same as / (?: a | b ) /

=head2 Error Message

An error message is a string inside backticks. If the parser gets to an error
message in the grammar, it throws a parse error with that message.

    `error message`

=head2 Operators

The Pegex operators in descending precedence order are: ALT, AND, and OR.

AND and OR are the most common operators. AND is represented by the absence of
an operator. Like in these rules:

    r1: <a><b>
    r2: a b

Those are both the same. They mean rule C<a> AND (followed immediately by)
rule C<b>.

OR means match one or the other.

    r: a | b | c

means match rule C<a> OR rule C<b> OR rule C<c>. The rules are checked in
order and if one matches, the others are skipped.

ALT means alternation. It's a way to specify a separator in a list.

    r: a+ % b

would match these:

    a
    aba
    ababa

C<%%> means that a trailing separator is optional.

    r: a+ %% b

would match these:

    a
    ab
    aba
    abab

ANY operators take precedence over everything else, similar to other parsers.
These rules have the same binding precedence:

    r1: a b | c % d
    r2: (a b) | (c % d)

Parens are not only used for indicating binding precedence; they also can
create quantifiable groups:

    r1: (a b)+ c

would match:

    abababac

=head1 Return Values

All return values are based on the capture groups (C<$1/$2/$3/etc.> type
variables) of parsed RE statements. The exact structure of the result tree
depends on the type of Receiver used. For example, L<Pegex::Tree> will return:

    $1              # single capture group
    [ @+[1..$#+] ]  # multiple capture groups

This would be a match directly from the RE rule. As rules go further
back, things are put into arrays, but only if there is more than one
result. For example:

    r: (a b)+ % +
    a: /( ALPHA+ )/
    b: /( DIGIT+ )( PLUS )/

    # input = foobar123+
    # output (using Pegex::Tree) = [
    #     'foobar', [ '123', '+' ]
    # ]
    #
    # input = foobar123+ boofar789+
    # output (using Pegex::Tree) = [
    #     [ 'foobar', [ '123', '+' ] ],
    #     [ 'boofar', [ '789', '+' ] ],
    # ]

=head2 Skipping

Any rule can use the skip modifier (DOT) to completely skip the return from
that rule (and any children below it). The rule is still processed, but
nothing is put into the tree. (This is different from, say, putting C<undef>
into the return.) This can also affect the number of values returned, and
thus, whether a value comes as an array:

    r: (a .b)+ % +
    a: /( ALPHA+ )/
    b: /( DIGIT+ )( PLUS )/

    # input = foobar123+ boofar789+
    # output (using Pegex::Tree) = [
    #     'foobar',
    #     'boofar',
    # ]

The skip modifier can also be used with groups. (This is the only group
modifier allowed so far.)

    r: .(a b)+ % +
    a: /( ALPHA+ )/
    b: /( DIGIT+ )( PLUS )/

    # output (using Pegex::Tree) = []

=head2 Wrapping

You can also turn on "wrapping" with the L<Pegex::Tree::Wrap> receiver. This
will wrap all match values in a hash with the rule name, like so:

    { rule_A => $match }
    { rule_B => [ @matches ] }

Note that this behavior can be "hard set" with the C<+/-> rule modifiers:

    -rule  # Flatten array captures
    +rule  # Always wrap (even if using Pegex::Tree)

This is simply a check in the C<gotrule> for the receiver. So, any specific
C<got_*> receiver methods will override even these settings, and choose to
pass the match as-is. In this case, the C<got_*> sub return value dictates
what ultimately gets put into the tree object:

    +rule_A   # in this case, the + is useless here

    sub got_rule_A {
        my ($self, $matches_arrayref) = @_;
        return $matches_arrayref;
        # will be received as [ @matches ]
    }

You can "correct" this behavior by passing it back to C<gotrule>:

    +rule_A   # now + is honored

    sub got_rule_A {
        my ($self, $matches_arrayref) = @_;
        return $self->gotrule($matches_arrayref);
        # will be received as { rule_A => [ @matches ] }
    }

=head1 See Also

=over

=item * L<Pegex::API>

=item * L<Pegex::Tutorial>

=item * L<Pegex::Resources>

=back

=cut
