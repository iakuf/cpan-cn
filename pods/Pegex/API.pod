=pod

=for comment
DO NOT EDIT. This Pod was generated by Swim v0.1.38.
See http://github.com/ingydotnet/swim-pm#readme

=encoding utf8

=head1 The Pegex API

Pegex 可以用在很多方面: 内部脚本, 从命令行或作为一个模块化的分析框架的基础. 本文档详细介绍了使用 Pegex 各种方法.

Pegex 这样工作:

    $result = $parser->new($grammar, $receiver)->parse($input);

在这个地方， 有一个 Pegex 解析器对象， 接着一个 Pegex grammar 的语法指示变量 $grammar, 当解析输的流时找到结果会给结果报告给 $receiver.

在这个 $parser, $grammar, $receiver 和输入，在 Pegex 对象中，由这四个对象的调用与参与完成 Pegex 的解析操作. 让我们来看看这些东西.

=over

=item L<Pegex::Parser>

这是 Pegex 解析引擎。 这个引擎会给 grammar 语法的逻辑应用于输入文本.  一个 B<parser> 包含了 B<grammar> 对象和 B<receiver> 对象。

这个对象的主要的可调用的方法是 C<parse>. 默认的解析引擎是非回溯, 递归下降. 当然可以通过子类来实现各种各样的类型的解析.

=item L<Pegex::Grammar>

在 Pegex grammar 最开始是一个文本文件/字符串组成内部是 B<Pegex> 语法.
要成为一个 Parser 的解析器, 它必须先编译. 在编译之后, 它变成一个数据树内部是由各种规则和正则表达式组成.
在模块中是 pegex grammar 语法会编译成类文件. 我们在 Pegex 本身中要使用  Pegex grammar 类直接通过调用 L<Pegex::Pegex::Grammar> 来解析各种 Pegex grammars.

=item L<Pegex::Receiver>

一个解析其实是不知道文件匹配的时候要做什么的. Pegex 的 B<receiver> 类它中间有很多方法和 grammar 中的 rule 规则相对应.
当 grammar 中的 rule 规则相匹配的时候, 它所一致的 receiver 方法会被调用并传入匹配到的数据. 
所以 receiver 所做的工作就是给数据做一些 action 的动作，常常会 build 这个东西成为一些新的结构.
Pegex 会使用 L<Pegex::Tree::Wrap> 做为默认的 receiver; 它生成合适的容易读的树型匹配/抓获的数据.

=item L<Pegex::Input>

Pegex 是抽取输入的流到对象的接口. 任何操作都是取得输入的字符, 也可以是取得输入的对象.
Pegex 会返回规则的字符到对象. 这个 API 的概念接下来就会用到.

=back

All of these object classes can be subclassed to acheive various results.
Normally, you will write your own Pegex grammar and a Pegex receiver to
achieve a task.

=head2 Starting Simple - The C<pegex> Function

使用 L<Pegex> 模块会导出一个函数叫 C<pegex>. 

    use Pegex;
    use YAML;

    $grammar = "
    expr: num PLUS num
    num: /( DIGIT+ )/
    ";

    print Dump pegex($grammar)->parse('2+2');

这个程序会输出:

    expr:
    - num: 2
    - num: 2

让我们看看，这做些什么， 我们使用 L<Pegex> 的模块导出 C<pegex> 的功能函数.
这个函数会取得 $grammar 变量中的语法做为输入. 在这个内部编译 grammar 字符成 grammar 对象.
这个所创建的对象，包含 grammar 的对象，并会给这个对象做为返回.

在这 parse 的方法在调用的时候，输入的是 C<'2+2'> 的字符. 如果这个字符相符能匹配上就会返回相应合适的数据结构.

所以，在这这个数据结构是怎么创建的? 这当然是由默认的 receiver 对象创建. 我们不一定要指定，这样就会使用默认的 L<Pegex::Tree::Wrap>. 这相当于:

    print Dump pegex($grammar, 'Pegex::Tree::Wrap')->parse('2+2');

这个 receiver 主要是生成一个数据映射, 当规则 (rule) 名字匹配到 keys 和支叶上的值由正则捕获.

这个基本的 receiver 可以调用 L<Pegex::Tree> 来生成顺序的包含数据的树(通过 rule name). 这代码是.

    print Dump pegex($grammar, 'Pegex::Tree')->parse('2+2');

这会生成:

    - 2
    - 2

如果我们想写自己的 receiver 类，如 C<Calculator> 只需要象下面这样:

    package Calculator;
    use base 'Pegex::Tree';

    sub got_expr {
        my ($receiver, $data) = @_;
        my ($a, $b) = @$data;
        return $a + $b;
    }

接着, 我们调用.

    print pegex(grammar, 'Calculator')->parse('2+2');

这会打印:

    4

=head2 More Explicit Usage

接着上面的例子，我们看怎么样生成一个更加正式的小例子.

    use Pegex::Parser;
    use Pegex::Grammar;
    use Pegex::Tree;
    use Pegex::Input;

    $grammar_text = "
    expr: num PLUS num
    num: /( DIGIT+ )/
    ";

    $grammar = Pegex::Grammar->new(text => $grammar_text);
    $receiver = Pegex::Tree->new();
    $parser = Pegex::Parser->new(
        grammar => $grammar,
        receiver => $receiver,
    );
    $input = Pegex::Input->new(string => '2+2');

    print Dump $parser->parse($input);

这个代码很象第一个例子，但在这，我们是自己手工的使用所有的对象.

=head2 Precompiled Grammars

如果你想给 Pegex grammar 打包成 CPAN 的发行包的一部分, 你想提前给这个编译成模块, Pegex 非常容易.

这的 grammar_text 是存成一个叫 C<share/expr.pgx> 的文件. 如果你想创建的模块叫
C<lib/MyThing/Grammar.pm> .

    package MyThing::Grammar;
    use base 'Pegex::Grammar';
    use constant file => './share/expr.pgx';
    sub make_tree {
    }
    1;

运行下面的命令:

    perl -Ilib -MMyThing::Grammar=compile

我们会重写你的模块, 变成象下面这样:

    package MyThing::Grammar;
    use base 'Pegex::Grammar';
    use constant file => './share/expr.pgx';
    sub make_tree {
      { '+toprule' => 'expr',
        'PLUS' => { '.rgx' => qr/\G\+/ },
        'expr' => {
          '.all' => [
            { '.ref' => 'num' },
            { '.ref' => 'PLUS' },
            { '.ref' => 'num' }
          ]
        },
        'num' => { '.rgx' => qr/\G([0-9]+)/ }
      }
    }
    1;

这个命令会找到你的 grammar 语法的文件，编译它，使用 L<Data::Dumper> 来输出到你的模块叫  C<make_tree> 的方法.

这就是 Pegex grammar 的编译过程，当然，你模块加载的时候，grammar 就是使用的 Pegex 的语法.

如果你发现你在开发的时候需要编译大量的 grammar 模块.你可以设置环境变化:

    export PERL_PEGEX_AUTO_COMPILE=MyThing::Grammar

现在, 每天 grammar 模块在加载的时候，它都会检查如果是否需要重新编译.

如果你有更多 grammar 模块要这样做, 你只需要在后面按顺序列出你的名字, 并使用逗号分开就好.

=head1 See Also

=over

=item * L<Pegex::Parser>

=item * L<Pegex::Grammar>

=item * L<Pegex::Receiver>

=item * L<Pegex::Tree>

=item * L<Pegex::Tree::Wrap>

=item * L<Pegex::Input>

=back

=cut
