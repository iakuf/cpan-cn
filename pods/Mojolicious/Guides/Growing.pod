=pod

=encoding utf8

=head1 文档

Mojolicious::Guides::Growing - 成长成更大型的项目

=head1 概述

本文档介绍中，我们来讲怎么从 L<Mojolicious::Lite> 开始做的原型项目，成长为一个结构良好的的全或功能 L<Mojolicious> 应用。

=head1 概念

所有 L<Mojolicious> 的开发者都需要知道。

=head2 Model View Controller

MVC 是一种现代的软件体系结构的模式，它起源于 Smalltalk-80 的图形界面编程，用于分离应用程序逻辑，表示和输入。

           +------------+    +-------+    +------+
  Input -> | Controller | -> | Model | -> | View | -> Output
           +------------+    +-------+    +------+

目前基本只需要给现在有程序小量的修改就可以转到 C<controller> 这种模式上来。目前基本每个 Web 的框架都是基于 MVC 的结构，包括  L<Mojolicious>.

              +----------------+     +-------+
  Request  -> |                | <-> | Model |
              |                |     +-------+
              |   Controller   |
              |                |     +-------+
  Response <- |                | <-> | View  |
              +----------------+     +-------+

在上面这个结构中 C<controller> 接收到用户的请求后，传送这些数据给 C<model> 处理完数据，然后通过 C<view> 转化为实际的响应。但要注意，这种模式只是一个指导方针，最重要的目标是有更干净和易于维护的代码。

=head2 REpresentational State Transfer

RESR 是一种 Web 软件架构的风格, 近来常常用于给 HTTP 做协议. 在 REST 中，你可以打开 C<http://mojolicio.us/foo> 这个 URL 在你的浏览器中，你相当于告诉你的 Web 服务来进行一个 HTML 的表示这个地址的资源。

  +--------+                                +--------+
  |        | -> http://mojolicio.us/foo  -> |        |
  | Client |                                | Server |
  |        | <- <html>Mojo rocks!</html> <- |        |
  +--------+                                +--------+

这里的基本思想是，所有的资源都是有一个唯一的 URL 来进行查寻，并且每个资源都可以有不同的表示方式，如 HTML, RSS 和 JSON 。让界面从数据层分离出来只需要注意和用户会议的状态进行互交。

  +---------+                        +------------+
  |         | ->    PUT /foo      -> |            |
  |         | ->    Hello world!  -> |            |
  |         |                        |            |
  |         | <-    201 CREATED   <- |            |
  |         |                        |            |
  |         | ->    GET /foo      -> |            |
  | Browser |                        | Web Server |
  |         | <-    200 OK        <- |            |
  |         | <-    Hello world!  <- |            |
  |         |                        |            |
  |         | ->    DELETE /foo   -> |            |
  |         |                        |            |
  |         | <-    200 OK        <- |            |
  +---------+                        +------------+

虽然 HTTP 的方法象 C<PUT>, C<GET> 和 C<DELETE> 并不是 REST 的一部分，但他们用来管理资源非常不错.

=head2 Sessions

Web 服务上的 HTTP 本来就被设计成一个无状态的协议，所以我们并不知道是否是以前的请求，这使得让用户友好登录到系统变得非常棘手。Sessions 就是用来解决这个问题，使得网络应用中跨多个 HTTP 请求后还能保留状态信息。

  GET /login?user=sri&pass=s3cret HTTP/1.1
  Host: mojolicio.us

  HTTP/1.1 200 OK
  Set-Cookie: sessionid=987654321
  Content-Length: 10
  Hello sri.

  GET /protected HTTP/1.1
  Host: mojolicio.us
  Cookie: $Version=1; sessionid=987654321

  HTTP/1.1 200 OK
  Set-Cookie: sessionid=987654321
  Content-Length: 16
  Hello again sri.

传统的上，所有的 session 会话数据存储在服务器端的，只有 Session 中会话的 ID 以 Cookie 的形式在 Web 服务器和浏览器之间交换。

  HTTP/1.1 200 OK
  Set-Cookie: session=base64(hmac-sha1(json($session)))

在 L<Mojolicious> 中对 session 进行了进一步的处理，使用 C<HMAC-SHA1> 签署 cookie, 这更兼容 REST 的理念并降低一些其它的要求.

=head2 测试驱动开发(Test Driven Development)

TDD，是一种不同于传统软件开发流程的新型的开发方法。它要求在编写某个功能的代码之前先编写测试代码，然后只编写使测试通过的功能代码，通过测试来推动整个开发的进行。这有助于编写简洁可用和高质量的代码，并加速开发过程。有许多优点，如始终具有良好的测试覆盖率和代码的可测试性设计，这将反过来往往防止未来的变化影响旧的代码的功能。大多的 L<Mojolicious> 使用 TDD 开发;

=head1 原型 

L<Mojolicious> 和其他 Web 框架的主要区别之一是，它还包括有一个 L<Mojolicious::Lite>，这是一个微型的 Web 框架，为快速实现原型优化过的。

=head2 差异

你有一些很好的主意，有很酷的想法，你想尽可能快地尝试实现它，这也是为什么 L<Mojolicious::Lite> 写的应用程序不需要超过一个单个文件的原因。

  myapp.pl   # Templates and even static files can be inlined

全功能的 L<Mojolicious> 应用程序更加接近象一个 CPAN 的发布包一样，有着良好结构，以最大限度的提高可维护性.

  myapp                      # 应用程序的目录 
  |- script                  # 脚本的目录 
  |  +- myapp                # 应用程序的脚本  
  |- lib                     # Library 的目录 
  |  |- MyApp.pm             # 应用程序的类 
  |  +- MyApp                # 应用程序的名字空间 
  |     +- Example.pm        # Controller 类
  |- t                       # 测试目录 
  |  +- basic.t              # Random test
  |- log                     # 日志目录 
  |  +- development.log      # 开发模式的日志
  |- public                  # 静态文件的目录 (served automatically)
  |  +- index.html           # 静态 HTML 文件
  +- templates               # 模板目录
     |- layouts              # 模板目录和 layout
     |  +- default.html.ep   # Layout 模板 
     +- example              # "Example"  controller 的模板目录
        +- welcome.html.ep   # "welcome" 动作的模板

这二种应用类型的骨架，可以使用 generate 来自动生成.

  $ mojo generate lite_app
  $ mojo generate app

=head2 基础

我们开始我们新的应用程序使用单个可执行的 Perl 程序。

  $ mkdir myapp
  $ cd myapp
  $ touch myapp.pl
  $ chmod 744 myapp.pl

这是我们 login manager 的样例程序的一个基础。

  #!/usr/bin/env perl
  use Mojolicious::Lite;

  get '/' => sub {
    my $self = shift;
    $self->render(text => 'Hello world!');
  };

  app->start;

内置的 Web 开发服务器有个非常好的地方，就是会自动的在你的程序变化更新后重新加载。你不在需要手工的重起.

  $ morbo myapp.pl
  Server available at http://127.0.0.1:3000.

当你保存你的修改后，会在你下一次刷新浏览器的时候就会自动生效了.

=head2 Model

在 L<Mojolicious>  中，我们认为 Web 应用是现有业务逻辑的简单前端, 这意味着 L<Mojolicious> 设计完全是和   L<model> 层无关的，你可以使用任意的 Perl 模块来替换。

  $ mkdir lib
  $ touch lib/MyUsers.pm
  $ chmod 644 lib/MyUsers.pm

我们的登录管理,将只使用一个普通的原有 Perl 模块抽象出，来匹配用户名和密码这个工作相关的逻辑。

  package MyUsers;

  use strict;
  use warnings;

  my $USERS = {
    sri    => 'secr3t',
    marcus => 'lulz',
    yko    => 'zeecaptain'
  };

  sub new { bless {}, shift }

  sub check {
    my ($self, $user, $pass) = @_;

    # Success
    return 1 if $USERS->{$user} && $USERS->{$user} eq $pass;

    # Fail
    return undef;
  }

  1;

如果你想实现自己的 C<model> 的动作和模板，你可以使用  L<Mojolicious/"helper">  的功能来注册你的方法。

  #!/usr/bin/env perl
  use Mojolicious::Lite;

  use lib 'lib';
  use MyUsers;

  # Model object
  my $users = MyUsers->new;

  # Helper function returning our model object
  helper users => sub { return $users };

  # /?user=sri&pass=secr3t
  any '/' => sub {
    my $self = shift;

    # Query parameters
    my $user = $self->param('user') || '';
    my $pass = $self->param('pass') || '';

    # Check password
    return $self->render(text => "Welcome $user.")
      if $self->users->check($user, $pass);

    # Failed
    $self->render(text => 'Wrong username or password.');
  };

  app->start;

这个 L<Mojolicious::Controller/"param">  的方法会取得请求过来的参数，POST 的参数，文件上传送的内容和 Route 的占位符取得的内容.和其它.

=head2 测试 Testing

在 L<Mojolicious> 中我们希望大家能都认真的采用测试驱动开发，并努力推动它.

  $ mkdir t
  $ touch t/login.t
  $ chmod 644 t/login.t

L<Test::Mojo> 是一个脚本化的 HTTP user agent ，设计是专门用于测试的，它有非常多有趣的功能如基于 CSS 选择器的 L<Mojo::DOM>.

  use Test::More;
  use Test::Mojo;

  # Include application
  use FindBin;
  require "$FindBin::Bin/../myapp.pl";

  # Allow 302 redirect responses
  my $t = Test::Mojo->new;
  $t->ua->max_redirects(1);

  # Test if the HTML login form exists
  $t->get_ok('/')
    ->status_is(200)
    ->element_exists('form input[name="user"]')
    ->element_exists('form input[name="pass"]')
    ->element_exists('form input[type="submit"]');

  # Test login with valid credentials
  $t->post_form_ok('/' => {user => 'sri', pass => 'secr3t'})
    ->status_is(200)->text_like('html body' => qr/Welcome sri/);

  # Test accessing a protected page
  $t->get_ok('/protected')->status_is(200)->text_like('a' => qr/Logout/);

  # Test if HTML login form shows up again after logout
  $t->get_ok('/logout')->status_is(200)
    ->element_exists('form input[name="user"]')
    ->element_exists('form input[name="pass"]')
    ->element_exists('form input[type="submit"]');

  done_testing();

从现在开始，在你的应用程序中，你随时可以检查的你的程序，通过运行这些单元测试.

  $ ./myapp.pl test
  $ ./myapp.pl test t/login.t

为了减少一些测试时的其它东西，你可以调整你的日志只输出 C<error> 的信息.

  $t->app->log->level('error');

快速的测试 C<GET> 请求可以执行这个命令。

  $ ./myapp.pl get /
  Wrong username or password.

  $ ./myapp.pl get -v '/?user=sri&pass=secr3t'
  HTTP/1.1 200 OK
  Connection: Keep-Alive
  Date: Sun, 18 Jul 2010 13:09:58 GMT
  Server: Mojolicious (Perl)
  Content-Length: 12
  Content-Type: text/plain

  Welcome sri.

=head2 State keeping

Sessions 在 L<Mojolicious> 中非常简单，直接可以通过 L<Mojolicious::Controller/"session"> 方法来使用，不过建议你使用更加安全的通过 L<Mojolicious/"secret"> 来设置个密码短语。

  app->secret('Mojolicious rocks');

这个密码短语是使用的 C<HMAC-SHA1> 算法来签名你的 cookie , 并可以随时改变让所有现有会话无效。

  $self->session(user => 'sri');
  my $user = $self->session('user');

默认的 sessions 的有效时间为一个小时，如果你想自己控制，就使用 C<expiration> 的参数，来设置 session 方法中的值就可以了。

  $self->session(expiration => 3600);

可以通过设置 C<expires>  来让会话过期，如果要删除就使用你个过去的时间就好了。

  $self->session(expires => 1);

对于只让下一个请求可见的信息，象下面这个 302 的重定向，你可以使用 L<Mojolicious::Controller/"flash"> 的方法。

  $self->flash(message => 'Everything is fine.');
  $self->redirect_to('goodbye');

你需要知道的就是所有的会话的数据都被 L<Mojo::JSON> 实例化并使用 C<HMAC-SHA1> 签名 cookie 来存储的。通常浏览器对这个数据有 4096 个字节的限制需要你注意.

=head2 最终的原型

上面那个最终的原型 C<myapp.pl> 会是下面这个样子。

  #!/usr/bin/env perl
  use Mojolicious::Lite;

  use lib 'lib';
  use MyUsers;

  # Make signed cookies secure
  app->secret('Mojolicious rocks');

  my $users = MyUsers->new;
  helper users => sub { return $users };

  # Main login action
  any '/' => sub {
    my $self = shift;

    # Query or POST parameters
    my $user = $self->param('user') || '';
    my $pass = $self->param('pass') || '';

    # Check password and render "index.html.ep" if necessary
    return $self->render unless $self->users->check($user, $pass);

    # Store username in session
    $self->session(user => $user);

    # Store a friendly message for the next page in flash
    $self->flash(message => 'Thanks for logging in.');

    # Redirect to protected page with a 302 response
    $self->redirect_to('protected');
  } => 'index';

  # A protected page auto rendering "protected.html.ep"
  get '/protected' => sub {
    my $self = shift;

    # Redirect to main page with a 302 response if user is not logged in
    return $self->redirect_to('index') unless $self->session('user');
  };

  # Logout action
  get '/logout' => sub {
    my $self = shift;

    # Expire and in turn clear session automatically
    $self->session(expires => 1);

    # Redirect to main page with a 302 response
    $self->redirect_to('index');
  };

  app->start;
  __DATA__

  @@ index.html.ep
  % layout 'default';
  %= form_for index => begin
    % if (param 'user') {
      <b>Wrong name or password, please try again.</b><br>
    % }
    Name:<br>
    %= text_field 'user'
    <br>Password:<br>
    %= password_field 'pass'
    <br>
    %= submit_button 'Login'
  % end

  @@ protected.html.ep
  % layout 'default';
  % if (my $msg = flash 'message') {
    <b><%= $msg %></b><br>
  % }
  Welcome <%= session 'user' %>.<br>
  %= link_to Logout => 'logout'

  @@ layouts/default.html.ep
  <!DOCTYPE html>
  <html>
    <head><title>Login Manager</title></head>
    <body><%= content %></body>
  </html>

全部的原生的 helpers 可以看  L<Mojolicious::Plugin::DefaultHelpers> 和  L<Mojolicious::Plugin::TagHelpers>.

=head1 完整结构的应用 

L<Mojolicious> 非常的灵活，所以在实际变成完整应用时有很多的变化，这给你很好的概括了各种可能性.

=head2 Inflating templates

所有在 C<DATA> 的部分的内容的静态文件和模板，可以自动的生成并放在 C<templates> 和 C<public> 的目录.

  $ ./myapp.pl inflate

这些目录会优先取得内容,比起本身的 C<DATA> 部分，所以 inflating 可以让你定制你的应用。

=head2 简单的应用程序的类 

这些东西是整个 L<Mojolicious> 应用的心脏，这些内容在 Web 服务启动的过程中被实例化.

  $ touch lib/MyApp.pm
  $ chmod 644 lib/MyApp.pm

我们开始从  C<myapp.pl> 提取出所有 action 的代码，放到指定的目录中，变成 L<Mojolicious::Routes> 中混合的 route 。我们并不需要改变实际的功能代码.

  package MyApp;
  use Mojo::Base 'Mojolicious';

  use MyUsers;

  sub startup {
    my $self = shift;

    $self->secret('Mojolicious rocks');
    my $users = MyUsers->new;
    $self->helper(users => sub { return $users });

    my $r = $self->routes;

    $r->any('/' => sub {
      my $self = shift;

      my $user = $self->param('user') || '';
      my $pass = $self->param('pass') || '';
      return $self->render unless $self->users->check($user, $pass);

      $self->session(user => $user);
      $self->flash(message => 'Thanks for logging in.');
      $self->redirect_to('protected');
    } => 'index');

    $r->get('/protected' => sub {
      my $self = shift;
      return $self->redirect_to('index') unless $self->session('user');
    });

    $r->get('/logout' => sub {
      my $self = shift;
      $self->session(expires => 1);
      $self->redirect_to('index');
    });
  }

  1;

这设置整个应用程序和实例化的地方 ，这个 C<startup> 的方法被调用后。

=head2 简单的应用的脚本 

这个 C<myapp.pl> 本身可以变成一个简单的应用程序来让你在次运行所有的程序。

  #!/usr/bin/env perl

  use strict;
  use warnings;

  use lib 'lib';
  use Mojolicious::Commands;

  # Start commands for application
  Mojolicious::Commands->start_app('MyApp');

=head2 Controller class

混合起来的 routes 很容易几步就实现，要最大限度地提高可维护性是有意义的，分离我们的操作代码和它的路由信息就可以达到这个目标.

  $ mkdir lib/MyApp
  $ touch lib/MyApp/Login.pm
  $ chmod 644 lib/MyApp/Login.pm

当然，实际的功能代码还是不需要修改。

  package MyApp::Login;
  use Mojo::Base 'Mojolicious::Controller';

  sub index {
    my $self = shift;

    my $user = $self->param('user') || '';
    my $pass = $self->param('pass') || '';
    return $self->render unless $self->users->check($user, $pass);

    $self->session(user => $user);
    $self->flash(message => 'Thanks for logging in.');
    $self->redirect_to('protected');
  }

  sub protected {
    my $self = shift;
    return $self->redirect_to('index') unless $self->session('user');
  }

  sub logout {
    my $self = shift;
    $self->session(expires => 1);
    $self->redirect_to('index');
  }

  1;

全部的 L<Mojolicious::Controller> 的 controller 就是普通的 Perl 的类。

=head2 Application class

这个 C<lib/MyApp.pm>  的应用的类，可以现在可以减少到只有模式和路由的信息.

  package MyApp;
  use Mojo::Base 'Mojolicious';

  use MyUsers;

  sub startup {
    my $self = shift;

    $self->secret('Mojolicious rocks');
    my $users = MyUsers->new;
    $self->helper(users => sub { return $users });

    my $r = $self->routes;
    $r->any('/')->to('login#index')->name('index');
    $r->get('/protected')->to('login#protected')->name('protected');
    $r->get('/logout')->to('login#logout')->name('logout');
  }

  1;

这个 L<Mojolicious::Routes> 可以有非常多的 route 的变化， 选出你最喜欢的方式.

=head2 Templates

我们给模板绑定到控制器, 所以需要给他们移动到相应的目录.

  $ mkdir templates/login
  $ mv templates/index.html.ep templates/login/index.html.ep
  $ mv templates/protected.html.ep templates/login/protected.html.ep

=head2 Script

最终的 C<myapp.pl>  替换成 L<Mojolicious> 的脚本.

  $ rm myapp.pl
  $ mkdir script
  $ touch script/myapp
  $ chmod 744 script/myapp

只有几个小的改变。

  #!/usr/bin/env perl

  use strict;
  use warnings;

  use FindBin;
  use lib "$FindBin::Bin/../lib";

  # Start commands for application
  require Mojolicious::Commands;
  Mojolicious::Commands->start_app('MyApp');

=head2 简单的 tests

标准的 L<Mojolicious> 应用程序更容易测试，所以 C<t/login.t> 可以简化.

  use Test::More;
  use Test::Mojo;

  # Load application class
  my $t = Test::Mojo->new('MyApp');
  $t->ua->max_redirects(1);

  $t->get_ok('/')
    ->status_is(200)
    ->element_exists('form input[name="user"]')
    ->element_exists('form input[name="pass"]')
    ->element_exists('form input[type="submit"]');

  $t->post_form_ok('/' => {user => 'sri', pass => 'secr3t'})
    ->status_is(200)->text_like('html body' => qr/Welcome sri/);

  $t->get_ok('/protected')->status_is(200)->text_like('a' => qr/Logout/);

  $t->get_ok('/logout')->status_is(200)
    ->element_exists('form input[name="user"]')
    ->element_exists('form input[name="pass"]')
    ->element_exists('form input[type="submit"]');

  done_testing();

测试驱动开发需要多一点时间，但很值得！

=head1 MORE

你现在可以看看 L<Mojolicious::Guides> 。现在也可以看看 L<Mojolicious wiki|http://github.com/kraih/mojo/wiki>,  这有很多文档和不同作者的例子.

=cut
