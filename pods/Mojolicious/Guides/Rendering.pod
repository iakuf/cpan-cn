=pod

=encoding utf8

=head1 文档


Mojolicious::Guides::Rendering - 渲染

=head1 概述

本文档介绍通过 L<Mojolicious> 来渲染生成内容。

=head1 概念

这是  L<Mojolicious> 一定都知道的。

=head2 Renderer

在这指的渲染器是一个很小黑盒子，把 stash 的数据转化为实际的响应，其中利用到多种模板系统和数据编码模块。

  {text => 'Hello.'}                 -> 200 OK, text/html, 'Hello.'
  {json => {x => 3}}                 -> 200 OK, application/json, '{"x":3}'
  {text => 'Oops.', status => '410'} -> 410 Gone, text/html, 'Oops.'

如果提供一些 route 之类的信息，模板可以被自动检测到。模板名遵循  C<name.format.handler> 规则，其中  C<name> 是定义的 C<controller/action> 或者是路由选择的名字，C<format> 默认是 C<html> ,其中 C<handler>  默认是 C<ep>.

  {controller => 'users', action => 'list'} -> 'users/list.html.ep'
  {name => 'foo', format => 'txt'}          -> 'foo.txt.ep'
  {name => 'foo', handler => 'epl'}         -> 'foo.html.epl'

全部的模板放在 C<templates> 的目录中，如果是单文件的应用就在 C<main> 类的 C<DATA> 部分。

  __DATA__

  @@ time.html.ep
  % use Time::Piece;
  % my $now = localtime;
  <!DOCTYPE html>
  <html>
    <head><title>Time</title></head>
    <body>The time is <%= $now->hms %>.</body>
  </html>

  @@ hello.txt.ep
  ...

渲染器可以很容易地扩展，以支持额外的模板系统的插件，但更多的后来。

=head2 Embedded Perl

L<Mojolicious> 包含简单但非常强大的模板系统，叫 Embedded Perl 或 C<ep>。它可以嵌入 Perl 代码，使用特别的标记并转化为实际的内容。

  <% Perl 代码 %>
  <%= Perl 表达式, 结果是 XML %>
  <%== Perl 表达式, 结果是什么就显示什么 %>
  <%# 注释, 用于 debug %>
  <%% 替换为 "<%", 用于生成模板 %>
  % Perl 代码行，和这个一样 "<% line =%>"
  %= Perl 表达式,这个一样  "<%= line %>"
  %== Perl 达式,这个一样 "<%== line %>"
  %# 注释,这个一样 "<%# line =%>"
  %% 换为 "%", 用于生成模板 

使用 <% 的 Tag 和使用 % 的行是一样的，但是根据不同的上下文时不同的内容看起来会好些。分号会自动追加到所有的表达式。

  <% my $i = 10; %>
  <ul>
    <% for my $j (1 .. $i) { %>
      <li>
        <%= $j %>
      </li>
    <% } %>
  </ul>

  % my $i = 10;
  <ul>
    % for my $j (1 .. $i) {
      <li>
        %= $j
      </li>
    % }
  </ul>

除了空白处理的差异，这两个例子产生类似 Perl 功能代码，我们可以天真的理解成这个样子。

  my $output = '';
  my $i = 10;
  $output .= '<ul>';
  for my $j (1 .. $i) {
    $output .= '<li>';
    $output .= xml_escape scalar $j;
    $output .= '</li>';
  }
  $output .= '</ul>';
  return $output;

一些额外的等号可以用于禁用在 Perl 表达式中的转义的字符 C<E<lt>>, C<E<gt>>, C<&>, C<'>  和  C<"> 。这是默认设置，以防止XSS攻击.

  <%= 'lalala' %>
  <%== '<p>test</p>' %>

仅  L<Mojo::ByteStream> 的对象是排除在自动转义之外的.

  <%= Mojo::ByteStream->new('<p>test</p>') %>

换行符可以用一个反斜杠转义。

  This is <%= 1 + 1 %> a\
  single line

一个换行符前的反斜杠，可以用另一个反斜杠转义。

  This will <%= 1 + 1 %> result\\
  in multiple\\
  lines

您还可以对结束标签添加额外的等号，它会自动删除所有周围的空白，可以自由缩进，而不破坏的结果。

  <% for (1 .. 3) { %>
    <%= $foo =%>
  <% } %>

Stash 的值不会有无效的字符的，因为它们的名字会在模板和 controller 的 C<$self> 的对象中中自动初始化。

  $self->stash(name => 'tester');

  Hello <%= $name %> from <%= $self->tx->remote_address %>.

在后面我们还会象很多的辅助功能

  <%= dumper {foo => 'bar'} %>

=head1 基础

每个 L<Mojolicious> 开发都都需要知道的最常用的功能.

=head2 自动渲染 

渲染可以通过调用方法 L<Mojolicious::Controller/"render"> 手动启动，但通常没有必要，因为路由完后会自动调用。 This also means you can have routes pointing only to templates without actual actions.

  $self->render;

这有个区别，在手动调用它时，是使用的当前的控制器对象，并不是 L<Mojolicious/"controller_class"> 中指定的默认的。

=head2 渲染模板 

渲染器会自动的检查合适的模板，当然你也可以使用 stash 中的变量  C<template>  来指定一个。

  $self->render(template => 'foo/bar');

选择特定的 C<format> 和 C<handler> 也很容易.

  $self->render(template => 'foo/bar', format => 'txt', handler => 'epl');

因为最常用的功能是显示指定的模板，所以上面的太过于复杂，可以使用下面的做为代替.

  $self->render('foo/bar');

=head2 渲染 inline 模板

象 C<ep> 之内，也可以允许内联来使用.

  $self->render(inline => 'The result is <%= 1 + 1%>.');

默认是使用自动来决定 handler 来做解析，你也可以指定 C<handler>。

  $self->render(inline => "<%= shift->param('foo') %>", handler => 'epl');

=head2 渲染文本 

在这我们可以直接显示 Perl 中的字符，只要使用  C<text> 就行了，这个会自动编码成字节数据。

  $self->render(text => 'Hello Wörld!');

=head2 渲染 data

原始字节可以使用 C<data>  的选项，这样不会对数据进行编码。

  $self->render(data => $octets);

=head2 渲染 JSON

这个只需要给使用 C<json> 的参数。然后提供一个 Perl 的数据结构就行了。

  $self->render(json => {foo => [1, 'test', 3]});

=head2 Partial rendering

Sometimes you might want to access the rendered result, for example to generate emails, this can be done using the C<partial> stash value.

  my $html = $self->render('mail', partial => 1);

=head2 Status code

响应码可以通过 C<status> 的变量来进行修改。

  $self->render(text => 'Oops.', status => 500);

=head2 Content type

这个  C<Content-Type> 的头是由  C<format> 的内容基于MIME类型映射的。

  $self->render(text => 'Hello.', format => 'txt');

这个映射可以由 L<Mojolicious/"types"> 中来扩展。

  # Application
  package MyApp;
  use Mojo::Base 'Mojolicious';

  sub startup {
    my $self = shift;

    # Add new MIME type
    $self->types->type(txt => 'text/plain; charset=utf-8');
  }

  1;

=head2 Stash 数据

任何原生的 Perl 数组类型都可以通过 L<Mojolicious::Controller/"stash"> 传给模板.

  $self->stash(author     => 'Sebastian');
  $self->stash(frameworks => [qw(Catalyst Mojolicious)]);
  $self->stash(examples   => {tweetylicious => 'a microblogging app'});

  %= $author
  %= $frameworks->[1]
  %= $examples->{tweetylicious}

所有的这些都是 Perl 标准的控制结构.

  % for my $framework (@$frameworks) {
    <%= $framework %> was written by <%= $author %>.
  % }

  % while (my ($app, $description) = each %$examples) {
    <%= $app %> is a <%= $description %>.
  % }

=head2 Content negotiation

在 C<RESTful> 的内容中，可以对资源有不同的显示方式，我们只需要使用 L<Mojolicious::Controller/"respond_to"> 来替换掉 L<Mojolicious::Controller/"render"> 来对不同的请求输出不同的东西.

  # /hello (Accept: application/json) -> "json"
  # /hello (Accept: application/xml)  -> "xml"
  # /hello.json                       -> "json"
  # /hello.xml                        -> "xml"
  # /hello?format=json                -> "json"
  # /hello?format=xml                 -> "xml"
  $self->respond_to(
    json => {json => {hello => 'world'}},
    xml  => {text => '<hello>world</hello>'}
  );

默认会根据请求头中的  C<Accept>， C<format> 的值和  C<format> 的请求参数来自动选择最好的表示方式。

  $self->respond_to(
    json => {json => {hello => 'world'}},
    html => sub {
      $self->content_for(head => '<meta name="author" content="sri" />');
      $self->render(template => 'hello', message => 'world')
    }
  );

回调可以在单个渲染中实现非常复杂的内容协商的功能。

  # /hello (Accept: application/json) -> "json"
  # /hello (Accept: text/html)        -> "html"
  # /hello (Accept: image/png)        -> "any"
  # /hello.json                       -> "json"
  # /hello.html                       -> "html"
  # /hello.png                        -> "any"
  # /hello?format=json                -> "json"
  # /hello?format=html                -> "html"
  # /hello?format=png                 -> "any"
  $self->respond_to(
    json => {json => {hello => 'world'}},
    html => {template => 'hello', message => 'world'},
    any  => {text => '', status => 204}
  );

任何没有发现的请求都会使用 C<any> 这个来响应一个空的 C<204> 的响应。

=head2 渲染 C<exception> 和 C<not_found> 的网页

到现在你可能见过了了内置的 404 （未找到）和 500（服务器错误）的网页，当出错时会自动被渲染输出。特别是在开发过程中，他们是一个很有帮助的。我们可以通过  L<Mojolicious::Controller/"render_exception">  和 L<Mojolicious::Controller/"render_not_found"> 的方法来定制自己的网页。

  use Mojolicious::Lite;
  use Scalar::Util 'looks_like_number';

  get '/divide/:dividend/by/:divisor' => sub {
    my $self = shift;
    my ($dividend, $divisor) = $self->param(['dividend', 'divisor']);

    # 404
    return $self->render_not_found
      unless looks_like_number $dividend && looks_like_number $divisor;

    # 500
    return $self->render_exception('Division by zero!') if $divisor == 0;

    # 200
    $self->render_text($dividend / $divisor);
  };

  app->start;

你也可以修改这些网页的模板，因为你可能很希望对不同的用户定制出错的网页，所以你可以使用内部的模板，直接在内部使用  C<exception.$mode.$format.*> 和  C<not_found.$mode.$format.*> 会默认被使用.

  @@ exception.production.html.ep
  <!DOCTYPE html>
  <html>
    <head><title>Server error</title></head>
    <body><%= $exception %></body>
  </html>

=head2 Helpers

Helpers  是一些小功能，你可以使用模板和控制器代码的功能. 

  %= dumper [1, 2, 3]

  my $serialized = $self->dumper([1, 2, 3]);

这个 L<Mojolicious::Plugin::DefaultHelpers/"dumper"> 的例子是使用的 L<Data::Dumper> 来实例化你的数据结构，这在 debug 的时候非常有效。这个还可以用来生成一些  C<HTML> 的标签。

  %= javascript '/script.js'

  %= javascript begin
    var a = 'b';
  % end

全部的原生的 heler 可以看看 L<Mojolicious::Plugin::DefaultHelpers> 和  L<Mojolicious::Plugin::TagHelpers>.


=head2 Layouts

大多的时候，我们是使用 C<ep> 模板。这个可用来封装你的 HTML ，布局之类。非常的简单.

  @@ foo/bar.html.ep
  % layout 'mylayout';
  Hello World!

  @@ layouts/mylayout.html.ep
  <!DOCTYPE html>
  <html>
    <head><title>MyApp</title></head>
    <body><%= content %></body>
  </html>

你需要使用 L<Mojolicious::Plugin::DefaultHelpers/"layout">  来选择合适的 layout 模板并给结果在当前的模板上通过  L<Mojolicious::Plugin::DefaultHelpers/"content"> 来显示。

  @@ foo/bar.html.ep
  % layout 'mylayout', title => 'Hi there';
  Hello World!

  @@ layouts/mylayout.html.ep
  <!DOCTYPE html>
  <html>
    <head><title><%= $title %></title></head>
    <body><%= content %></body>
  </html>

替代  C<layout> helper 也可以只调用 L<Mojolicious::Controller/"render"> 中的 C<layout> 参数。

  $self->render(template => 'mytemplate', layout => 'mylayout');

有关 C<layout> 的参数你可以看看 L<Mojolicious/"defaults">.

  # Application
  package MyApp;
  use Mojo::Base 'Mojolicious';

  sub startup {
    my $self = shift;

    # Default layout
    $self->defaults(layout => 'mylayout');
  }

  1;

=head2 包括部分模板 

使用  L<Mojolicious::Plugin::DefaultHelpers/"include">  的 helper 是一个很方便的功能.

  @@ foo/bar.html.ep
  <!DOCTYPE html>
  <html>
    %= include 'header'
    <body>Bar</body>
  </html>

  @@ header.html.ep
  <head><title>Howdy</title></head>

一样，你也可以调用  L<Mojolicious::Controller/"render"> 中来使用 C<partial> 的参数。

  @@ foo/bar.html.ep
  <!DOCTYPE html>
  <html>
    %= $self->render('header', partial => 1)
    <body>Bar</body>
  </html>

  @@ header.html.ep
  <head><title>Howdy</title></head>

这二个之间有一点点差别，就是如果你给 stash 的值传给  C<include>, 这会自动的本地化，并可用在局部模板中。

  @@ foo/bar.html.ep
  <!DOCTYPE html>
  <html>
    %= include 'header', title => 'Hello'
    <body>Bar</body>
  </html>

  @@ header.html.ep
  <head><title><%= $title %></title></head>

=head2 重用模板块 

如果总是重复一定不会有意思的，这也是为什么要重用的原困，在 C<ep> 的模板中也可以用，就象 Perl 的功能一样。

  @@ welcome.html.ep
  <% my $block = begin %>
    <% my $name = shift; %>
    Hello <%= $name %>.
  <% end %>
  <%= $block->('Sebastian') %>
  <%= $block->('Sara') %>

块是由 C<begin> 和  C<end> 关键字分隔的。

  @@ welcome.html.ep
  % my $block = begin
    % my $name = shift;
    Hello <%= $name %>.
  % end
  % for (1 .. 10) {
    %== $block->('Sebastian')
  % }

我们可以简单理解成象下面这样的 Perl 代码.

  @@ welcome.html.pl
  my $output = '';
  my $block  = sub {
    my $name   = shift;
    my $output = '';
    $output .= 'Hello ';
    $output .= xml_escape scalar $name;
    $output .= '.';
    return Mojo::ByteStream->new($output);
  }
  for (1 .. 10) {
    $output .= scalar $block->('Sebastian');
  }
  return $output;

=head2 Content blocks

块和 L<Mojolicious::Plugin::DefaultHelpers/"content_for"> 的 helper 也可以被用来传递到布局的模板的整个部分。

  @@ foo/bar.html.ep
  % layout 'mylayout';
  % content_for header => begin
    <meta http-equiv="Content-Type" content="text/html">
  % end
  <div>Hello World!</div>
  % content_for header => begin
    <meta http-equiv="Pragma" content="no-cache">
  % end

  @@ layouts/mylayout.html.ep
  <!DOCTYPE html>
  <html>
    <head><%= content_for 'header' %></head>
    <body><%= content %></body>
  </html>

=head2 模板继承 

继承布局概念之上又进了一步, 使用  L<Mojolicious::Plugin::DefaultHelpers/"content">  和  L<Mojolicious::Plugin::DefaultHelpers/"extends"> 可以让你建立一个框架模板，子块可以覆盖。

  @@ first.html.ep
  <!DOCTYPE html>
  <html>
    <head><title>Hello</title></head>
    <body>
      %= content header => begin
        Default header
      % end
      <div>Hello World!</div>
      %= content footer => begin
        Default footer
      % end
    </body>
  </html>

  @@ second.html.ep
  % extends 'first';
  % content header => begin
    New header
  % end

这是一种非常高级的模板重用

=head2 记忆模板的块 

编译模板缓存在内存中, 我们可以多走一步，使用  L<Mojolicious::Plugin::DefaultHelpers/"memorize"> 来防止模板块每次都被执行。

  @@ cached.html.ep
  % use Time::Piece;
  %= memorize begin
    This template was compiled at <%= localtime->hms %>.
  % end

=head2 增加 helpers

添加和重新定义  helper 是很容易的，你可以用它们做所有的事。

  use Mojolicious::Lite;

  helper debug => sub {
    my ($self, $string) = @_;
    $self->app->log->debug($string);
  };

  get '/' => sub {
    my $self = shift;
    $self->debug('action');
  } => 'index';

  app->start;
  __DATA__

  @@ index.html.ep
  % debug 'template';

Helpers 也可以使用 template 块做最后的参数，比如使用它做一个标签的过滤器.

  use Mojolicious::Lite;
  use Mojo::ByteStream;

  helper trim_newline => sub {
    my ($self, $block) = @_;
    my $result = $block->();
    $result =~ s/\n//g;
    return Mojo::ByteStream->new($result);
  };

  get '/' => 'index';

  app->start;
  __DATA__

  @@ index.html.ep
  %= trim_newline begin
    Some text.
    %= 1 + 1
    More text.
  % end

封装完的结果做成一个 L<Mojo::ByteStream> 的对象，可以防止被多次转义。

=head2 Helper 插件

有些 helpers 可能非常有用，我们想在多个应用程序之间来使用，所以使用 plugins 会很方便.

  package Mojolicious::Plugin::DebugHelper;
  use Mojo::Base 'Mojolicious::Plugin';

  sub register {
    my ($self, $app) = @_;
    $app->helper(debug => sub {
      my ($self, $string) = @_;
      $self->app->log->debug($string);
    });
  }

  1;

这个 C<register> 的方法会加载调用到你的应用中.

  use Mojolicious::Lite;

  plugin 'DebugHelper';

  get '/' => sub {
    my $self = shift;
    $self->debug('It works.');
    $self->render_text('Hello.');
  };

  app->start;

你可以使用下面的方法很容易的生成一个  C<CPAN> 兼容的插件.

  $ mojo generate plugin DebugHelper

当然这也提供了一个 C<PAUSE>  访问的接口给你。

  $ perl Makefile.PL
  $ make test
  $ make manifest
  $ make dist
  $ mojo cpanify -u USER -p PASS Mojolicious-Plugin-DebugHelper-0.01.tar.gz

=head2 Bundling assets with plugins

绑定静态文件和模板到你的应用和插件中很容易，即使你打算给他们放到 C<CPAN>.

  $ mojo generate plugin AlertAssets
  $ mkdir AlertAssets/lib/Mojolicious/Plugin/AlertAssets
  $ cd AlertAssets/lib/Mojolicious/Plugin/AlertAssets
  $ mkdir public
  $ echo 'alert("Hello World!");' > public/alertassets.js
  $ mkdir templates
  $ echo '%= javascript "/alertassets.js"' > templates/alertassets.html.ep

只需在 C<register> 调用的时候要追加其各自的目录到搜索路径的列表中。

  package Mojolicious::Plugin::AlertAssets;
  use Mojo::Base 'Mojolicious::Plugin';

  use File::Basename 'dirname';
  use File::Spec::Functions 'catdir';

  sub register {
    my ($self, $app) = @_;

    # Append "templates" and "public" directories
    my $base = catdir(dirname(__FILE__), 'AlertAssets');
    push @{$app->renderer->paths}, catdir($base, 'templates');
    push @{$app->static->paths},   catdir($base, 'public');
  }

  1;

这个就象存在标准的 C<templates> 和  C<public> 的目录一样，只要你安装了插件并加载了.

  use Mojolicious::Lite;

  plugin 'AlertAssets';

  get '/alert_me';

  app->start;
  __DATA__

  @@ alert_me.html.ep
  <!DOCTYPE html>
  <html>
    <head>
      <title>Alert me!</title>
      %= include 'alertassets'
    </head>
    <body>You've been alerted.</body>
  </html>

当然也可以使用  C<DATA> 块部分的数据.

  package Mojolicious::Plugin::AlertAssets;
  use Mojo::Base 'Mojolicious::Plugin';

  sub register {
    my ($self, $app) = @_;

    # Append class
    push @{$app->renderer->classes}, __PACKAGE__;
    push @{$app->static->classes},   __PACKAGE__;
  }

  1;
  __DATA__

  @@ alertassets.js
  alert("Hello World!");

  @@ alertassets.html.ep
  %= javascript "/alertassets.js"

=head1 高级

较不常用的但更强大的功能。

=head2 Chunked transfer encoding

=begin original

For very dynamic content you might not know the response C<Content-Length> in
advance, that's where the C<chunked> C<Transfer-Encoding> comes in handy. A
common use would be to send the C<head> section of an HTML document to the
browser in advance and speed up preloading of referenced images and
stylesheets.

=end original

对于动态的内容，你并不能提前知道响应的 C<Content-Length> 的大小，这时  C<chunked> C<Transfer-Encoding>  就非常有用。一个常见的用处是给 HTML 中发 C<head>  部分到用户的浏览器来提前加快预载图象和样式表。

  $self->write_chunk('<html><head><title>Example</title></head>' => sub {
    my $self = shift;
    $self->finish('<body>Example</body></html>');
  });

=begin original

The optional drain callback ensures that all previous chunks have been
written before processing continues. An empty chunk or call to
L<Mojolicious::Controller/"finish"> marks the end of the stream.

=end original

上面这个能保证 drain 的回调会给先前的数据写入完后，才会接着继续处理，一个空的 chunk 或者调用 L<Mojolicious::Controller/"finish">  标志着这个流结束了.

  29
  <html><head><title>Example</title></head>
  1b
  <body>Example</body></html>
  0

=begin original

Especially in combination with long inactivity timeouts this can be very useful for Comet (C<long polling>). Due to limitations in some web servers this might not work perfectly in all deployment environments.

=end original

特别是结合长时间闲置超时的应用象 Comet (C<long polling>) 时非常的有用。不过由于一些 Web 服务器的限制，并不能包证这个能在所有的地方都能正常工作.

=head2 Encoding

=begin original

Templates stored in files are expected to be C<UTF-8> by default, but that can be easily changed.

=end original

默认的模板是存成 C<UTF-8> 的格式，你也可以很容易的修改.

  # Application
  package MyApp;
  use Mojo::Base 'Mojolicious';

  sub startup {
    my $self = shift;

    # Different encoding
    $self->renderer->encoding('koi8-r');
  }

  1;

=begin original

All templates from the C<DATA> section are bound to the encoding of the Perl script, so don't forget to use the L<utf8> pragma if necessary.

=end original

如果从 C<DATA> 块中绑定模板到 Perl 的程序中时，不要忘记使用 L<utf8> 的编译指示.

  use Mojolicious::Lite;
  use utf8;

  get '/heart';

  app->start;
  __DATA__

  @@ heart.html.ep
  I ♥ Mojolicious!

=head2 Base64 encoded DATA files

=begin original

Base64 encoded static files such as images can be easily stored in the C<DATA> section of your application, similar to templates.

=end original

在你的应用程序中，你可以很容易的静态文件，如图片，存储在  C<DATA> 的部分，类似于模板一样.

  @@ favicon.ico (base64)
  ...base64 encoded image...

=head2 Inflating DATA templates

=begin original

Templates stored in files get preferred over files from the C<DATA> section,
this allows you to include a default set of templates in your application that
the user can later customize. The C<inflate> command will write all templates
and static files from the C<DATA> section into actual files in the
C<templates> and C<public> directories.

=end original

模板存储后，会从 C<DATA> 部分优先取得，所以可以让你在你的应用程序中包含默认的模板。当然你也可以以后进行自定义。使用 C<inflate> 的命令会给所有 C<DATA> 部分的静态文件都写到 C<templates> 和 C<public> 的目录中.

  $ ./myapp.pl inflate

=head2 定制模板语法

=begin original

You can easily change the whole template syntax by loading L<Mojolicious::Plugin::EPRenderer> with a custom configuration.

=end original

你可以很容易的通过 L<Mojolicious::Plugin::EPRenderer> 来定义你自己的模板语法的配置。

  use Mojolicious::Lite;

  plugin EPRenderer => {
    name     => 'mustache',
    template => {
      tag_start => '{{',
      tag_end   => '}}'
    }
  };

  get '/:name' => {name => 'Anonymous'} => 'index';

  app->start;
  __DATA__

  @@ index.html.mustache
  Hello {{= $name }}.

=begin original

L<Mojo::Template> contains the whole list of available options.

=end original

L<Mojo::Template>  中含可用选项的完整的列表

=head2 Adding your favorite template system

=begin original

Maybe you would prefer a different template system than C<ep>, all you have to do is add a new C<handler>.

=end original

也许你喜欢其它的模板系统，相比起 C<ep>。 你可以使用 C<handler> 来给新的模板系统加入到你的应用中来.

  use Mojolicious::Lite;

  app->renderer->add_handler(
    mine => sub {
      my ($renderer, $c, $output, $options) = @_;

      # Check for one time use inline template
      my $inline = $options->{inline};

      # Check for absolute template path
      my $path = $r->template_path($options);

      # Check for appropriate template in DATA section
      my $data = $r->get_data_template($options);

      # This part is up to you and your template system :)
      ...

      # Just die if an error occurs
      die 'Something went wrong';

      # Or pass the rendered result back to the renderer
      $$output = 'Hello World!';

      # And return true if something has been rendered or false otherwise
      return 1;
    }
  );

  get '/' => 'index';

  app->start;
  __DATA__

  @@ index.html.mine
  ...

=begin original

Since most template systems don't support templates in the C<DATA> section the
renderer provides methods to help you with that.

=end original

大多的模板系统都不支持从 C<DATA> 部分来取得模板，使用上面的方法可以帮你实现.

=head1 MORE

You can continue with L<Mojolicious::Guides> now or take a look at the
L<Mojolicious wiki|http://github.com/kraih/mojo/wiki>, which contains a lot
more documentation and examples by many different authors.

=cut
