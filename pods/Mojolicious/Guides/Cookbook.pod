=pod

=encoding utf-8

=head1 文档

Mojolicious::Guides::Cookbook - Cookbook

=head1 概述

许多有趣的烹饪 L<Mojolicious> 的食谱.

=head1 部署

我们可以让 L<Mojolicious> 和 L<Mojolicious::Lite> 的应用运行在不同的平台上，注意时实 web 特性是基于 L<Mojo::IOLoop> 的事件循环,因此，需要一个内置的 Web 服务器才能够使用它们来充分发挥其潜力。

=head2 内置的 Web 服务器 

L<Mojolicious> 内部包含了一个非常方便的非阻塞的  I/O HTTP 和 WebSocket 的 L<Mojo::Server::Daemon> 的服务器。这个常用于在开发中，也可以用它来创建更加先进的 web 服务器。
但是对于中小型的应用来讲，这个也足够快了.

  $ ./script/myapp daemon
  Server available at http://127.0.0.1:3000.

可以使用 -h 的选项看到更加多的配置参数.

  $ ./script/myapp daemon -h
  ...List of available options...

另一个巨大的好处是，它默认支持 TLS 和 WebSocket。

  $ ./script/myapp daemon -l https://*:3000
  Server available at https://127.0.0.1:3000.

这个内置了一个测试用的证书.

=head2 Morbo

如果你之前读过 L<Mojolicious::Lite> 这个指南，我想你已经知道 L<Mojo::Server::Morbo> 这个东西了。

  Mojo::Server::Morbo
  +- Mojo::Server::Daemon

它是基于 L<Mojo::Server::Daemon> 的 web 服务器 fork 出来并在你的代码变化时支持 restarter 功能，所以也只是用于开发当中.

  $ morbo script/myapp
  Server available at http://127.0.0.1:3000.

=head2 Hypnotoad

对于更加大的应用， L<Mojolicious> 包含 UNIX 优化过的 preforking 的 Web 服务器 L<Mojo::Server::Hypnotoad>. 它可以让利用多 CPU 和 copy-on-write.

  Mojo::Server::Hypnotoad
  |- Mojo::Server::Daemon [1]
  |- Mojo::Server::Daemon [2]
  |- Mojo::Server::Daemon [3]
  +- Mojo::Server::Daemon [4]

这个也可以基于 L<Mojo::Server::Daemon> 的 Web 来启动，但是对于生产环境进行了优化。

  $ hypnotoad script/myapp
  Server available at http://127.0.0.1:8080.

在您的应用程序，你可以调整许多设置, 有关设置的完整列表  L<Mojo::Server::Hypnotoad/"SETTINGS">.

  use Mojolicious::Lite;

  app->config(hypnotoad => {listen => ['http://*:3000']});

  get '/' => {text => 'Hello Wor...ALL GLORY TO THE HYPNOTOAD!'};

  app->start;

你也可以给这些有关 C<hypnotoad> 的设置写到你的 L<Mojolicious::Plugin::Config> 和 L<Mojolicious::Plugin::JSONConfig> 的配置文件中.

  # myapp.conf
  {hypnotoad => {listen => ['http://*:80'], workers => 10}};

但其最大的优点之一可以支持象 Nginx 一样的零停机的软件升级。这意味着你可以不用停止服务的前提下升级 L<Mojolicious>, Perl 或者是系统库。在你运行的时候你不用停止服务，也不用担心失去连接，只需要在次运行上面的命令.

  $ hypnotoad script/myapp
  Starting hot deployment for Hypnotoad server 31841.

如果你的 Hypnotoad 使用的环境是在反向代理之后，你可以让 L<Mojolicious> 自动的取得 C<X-Forwarded-For> 和 C<X-Forwarded-HTTPS> 的头。

  # myapp.conf
  {hypnotoad => {proxy => 1}};

你的应用程序是预装管理进程在启动过程中，你可以使用 L<Mojo::IOLoop> 的 timers 来运行代码在一个新的 forked 出来的 worker 进程中。

  use Mojolicious::Lite;

  Mojo::IOLoop->timer(0 => sub {
    app->log->info("Worker $$ star...ALL GLORY TO THE HYPNOTOAD!");
  });

  get '/' => {text => 'Hello Wor...ALL GLORY TO THE HYPNOTOAD!'};

  app->start;

=head2 Nginx

这可能是最流行的一个设置了，让你的应用的内置 Web 服务器工作在 Nginx 之后.

  upstream myapp {
    server 127.0.0.1:8080;
  }
  server {
    listen 80;
    server_name localhost;
    location / {
      proxy_read_timeout 300;
      proxy_pass http://myapp;
      proxy_set_header Host $host;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-HTTPS 0;
    }
  }

=head2 Apache/mod_proxy

另一个好的反向代理是 C<mod_proxy>，看起来和上面 Nginx 的配置非常相似。

  <VirtualHost *:80>
    ServerName localhost
    <Proxy *>
      Order deny,allow
      Allow from all
    </Proxy>
    ProxyRequests Off
    ProxyPreserveHost On
    ProxyPass / http://localhost:8080/ keepalive=On
    ProxyPassReverse / http://localhost:8080/
    RequestHeader set X-Forwarded-HTTPS "0"
  </VirtualHost>

=head2 Apache/CGI

当然你的 L<Mojolicious> 应用也支持 C<CGI> 的应用。这会自动检查你的环境。

  ScriptAlias / /home/sri/myapp/script/myapp/

=head2 PSGI/Plack

L<PSGI> 是你的 Perl 的 Web 框架和 Web 服务器之间的接口。其中的 L<Plack> 是一个 Perl 的模块和包含  L<PSGI> 中间件的一个工具,
它可以帮助你适配你的 Web 服务器. L<PSGI> 和 L<Plack> 灵感来自于 Python 的 WSGI 和 Ruby 的结构。 

  $ plackup ./script/myapp
  HTTP::Server::PSGI: Accepting connections at http://0:5000/

L<Plack> 为你提供了许多服务器和协议适配器，例如  C<FCGI>, C<SCGI> 和 C<mod_perl>. 你需要在你的应用的当前目录下来运行应用程序，不然可能有些库会找不到。

  $ plackup ./script/myapp -s FCGI -l /tmp/myapp.sock

因为是通过 C<plackup> 来加载你的应用， L<Mojolicious> 这时并不能发现你的应用的主目录，当然你可以设置你的  C<MOJO_HOME> 的环境变量。当然你也可以使用 C<app-E<gt>start> 在你的应用的启动脚本中来声明。以解决这个问题。

  $ MOJO_HOME=/home/sri/myapp plackup ./script/myapp
  HTTP::Server::PSGI: Accepting connections at http://0:5000/

=head2 Plack 的中间件

给你的程序使用脚本包起来成 C<myapp.fcgi> 这种来进行分离你的应用的逻辑是个很好的主意。

  #!/usr/bin/env plackup -s FCGI
  use Plack::Builder;

  builder {
    enable 'Deflater';
    require 'myapp.pl';
  };

你甚至可以用在您的应用程序中使用中间件。

  use Mojolicious::Lite;
  use Plack::Builder;

  get '/welcome' => sub {
    my $self = shift;
    $self->render(text => 'Hello Mojo!');
  };

  builder {
    enable 'Deflater';
    app->start;
  };

=head2 重写

有时您可能需要将应用程序部署在一个黑盒的环境下，你不能只是更改服务器配置或只是在一个后端反向代理服务器上，只有传送过来的 C<X-*> 的头, 你可以使用 C<before_dispatch> 来重写传入的请求.

  # Change scheme if "X-Forwarded-Protocol" header is set to "https"
  app->hook(before_dispatch => sub {
    my $self = shift;
    $self->req->url->base->scheme('https')
      if $self->req->headers->header('X-Forwarded-Protocol') eq 'https';
  });

由于有时使用反向代理不会传递相关请求的路径前缀，您的应用程序部署在这种环境下，重写请求的传送进来的基本路径也是很常见的。

  # Move first part from path to base path in production mode
  app->hook(before_dispatch => sub {
    my $self = shift;
    push @{$self->req->url->base->path->parts},
      shift @{$self->req->url->path->parts};
  }) if app->mode eq 'production';

=head2 应用嵌入

有时, 你可能想重用 L<Mojolicious> 的配置文件，数据库连接和 helpers 之类的脚本。这有个小型的服务器可以嵌入到你的应用让你可以实现这些。

  use Mojo::Server;

  # Load application with mock server
  my $server = Mojo::Server->new;
  my $app = $server->load_app('./myapp.pl');

  # Access fully initialized application
  say for @{$app->static->paths};
  say $app->config->{secret_identity};
  say $app->dumper({just => 'a helper test'});

=head2 Web 服务器嵌入 

你也可以使用原生的 Web 服务器嵌入到  L<Mojolicious>  的应用中。当然，不要忘记使用事件循环.

  use Mojolicious::Lite;
  use Mojo::IOLoop;
  use Mojo::Server::Daemon;

  # Normal action
  get '/' => {text => 'Hello World!'};

  # Connect application with web server and start accepting connections
  my $daemon
    = Mojo::Server::Daemon->new(app => app, listen => ['http://*:8080']);
  $daemon->start;

  # Call "one_tick" repeatedly from the alien environment
  Mojo::IOLoop->one_tick while 1;

=head1 实时 WEB

这个 real-time web 是一个集大成者，包含有 Comet (long-polling), EventSource 和 WebSocket, 这可以让内容尽快的 pushed 到消费者使用 long-lived 的连接,因为这是使用的并不是传统的 pull 模型。这个内置的 web 服务器使用 non-blocking I/O 和 基于 L<Mojo::IOLoop> 的事件循环，它提供了超级强大的功能，可以让你的 Web 应用同时服务数以千计的客户.

=head2 后端的 Web 服务 

由于 L<Mojo::UserAgent> 也是基于 L<Mojo::IOLoop> 的件循环，它并不是阻塞原生的内置 Web 服务器，使用了非阻塞就算是高延迟的 Web 后端也可以工作的很后.

  use Mojolicious::Lite;

  # Search Twitter for "perl"
  get '/' => sub {
    my $self = shift;
    $self->ua->get('http://search.twitter.com/search.json?q=perl' => sub {
      my ($ua, $tx) = @_;
      $self->render('twitter', results => $tx->res->json->{results});
    });
  };

  app->start;
  __DATA__

  @@ twitter.html.ep
  <!DOCTYPE html>
  <html>
    <head><title>Twitter results for "perl"</title></head>
    <body>
      % for my $result (@$results) {
        <p><%= $result->{text} %></p>
      % }
    </body>
  </html>

在有多个事件，如并行请求时，可以很容易地与的 L<Mojo::IOLoop> 做延迟同步.

  use Mojolicious::Lite;
  use Mojo::IOLoop;
  use Mojo::URL;

  # Search Twitter for "perl" and "python"
  get '/' => sub {
    my $self = shift;

    # Prepare response in two steps
    Mojo::IOLoop->delay(

      # Parallel requests
      sub {
        my $delay = shift;
        my $url   = Mojo::URL->new('http://search.twitter.com/search.json');
        $self->ua->get($url->clone->query({q => 'perl'})   => $delay->begin);
        $self->ua->get($url->clone->query({q => 'python'}) => $delay->begin);
      },

      # Delayed rendering
      sub {
        my ($delay, $perl, $python) = @_;
        $self->render(json => {
          perl   => $perl->res->json('/results/0/text'),
          python => $python->res->json('/results/0/text')
        });
      }
    );
  };

  app->start;

=head2 Timers

在 L<Mojo::IOLoop> 中另一个主要特征是定时器，这可以例如用于延迟渲染一个响应，和不同于 C<sleep>, 不会阻塞任何其他并行正在被处理的请求。

  use Mojolicious::Lite;
  use Mojo::IOLoop;

  # Wait 3 seconds before rendering a response
  get '/' => sub {
    my $self = shift;
    Mojo::IOLoop->timer(3 => sub {
      $self->render(text => 'Delayed by 3 seconds!');
    });
  };

  app->start;

周期性定时器更加强大，象 AnyEvent 一样，这个需要手动停止或一直执行.

  use Mojolicious::Lite;
  use Mojo::IOLoop;

  # Count to 5 in 1 second steps
  get '/' => sub {
    my $self = shift;

    # Start recurring timer
    my $i = 1;
    my $id = Mojo::IOLoop->recurring(1 => sub {
      $self->write_chunk($i);
      $self->finish if $i++ == 5;
    });

    # Stop recurring timer
    $self->on(finish => sub { Mojo::IOLoop->remove($id) });
  };

  app->start;

定时器不依赖于特定的连接请求，它甚至可以在启动时创建的。

  use Mojolicious::Lite;
  use Mojo::IOLoop;

  # Count seconds since startup
  my $i = 0;
  Mojo::IOLoop->recurring(1 => sub { $i++ });

  # Show counter
  get '/' => sub {
    my $self = shift;
    $self->render(text => "About $i seconds running!");
  };

  app->start;

因为记时器和其它的事件 watchers 一样独立于应用，错误会自动的记录到日志，如果你想自己完成回调，可以订阅 L<Mojo::Reactor/"error"> 的回调。

  # Forward error messages to the application log
  Mojo::IOLoop->singleton->reactor->on(error => sub {
    my ($reactor, $err) = @_;
    app->log->error($err);
  });

请记住，所有的事件都是协程，所以你要让你的回调不应该阻塞太长时间 。

=head2 WebSocket web service

WebSocket 协议提供完整的双向低延迟的在通信客户端和服务器之间的通道, 接收到信息可以非常方便的通过 L<Mojo::Transaction::WebSocket/"message">  中的 L<Mojolicious::Controller/"on"> 方法来回调。

  use Mojolicious::Lite;
  use Mojo::IOLoop;

  # Template with browser-side code
  get '/' => 'index';

  # WebSocket echo service
  websocket '/echo' => sub {
    my $self = shift;

    # Connected
    $self->app->log->debug('WebSocket connected.');

    # Increase inactivity timeout for connection a bit
    Mojo::IOLoop->stream($self->tx->connection)->timeout(300);

    # Incoming message
    $self->on(message => sub {
      my ($self, $msg) = @_;
      $self->send("echo: $msg");
    });

    # Disconnected
    $self->on(finish => sub {
      my $self = shift;
      $self->app->log->debug('WebSocket disconnected.');
    });
  };

  app->start;
  __DATA__

  @@ index.html.ep
  <!DOCTYPE html>
  <html>
    <head><title>Echo</title></head>
    <body>
      <script>
        var ws = new WebSocket('<%= url_for('echo')->to_abs %>');

        // Incoming messages
        ws.onmessage = function(event) {
          document.body.innerHTML += event.data + '<br/>';
        };

        // Outgoing messages
        window.setInterval(function() {
          ws.send('Hello Mojo!');
        }, 1000);
      </script>
    </body>
  </html>

在 WebSocket 的连接关掉时 L<Mojo::Transaction::WebSocket/"finish"> 会自动的调用。

=head2 测试 WebSocket web services

While the message flow on WebSocket connections can be rather dynamic, it more often than not is quite predictable, which allows this rather pleasant L<Test::Mojo> API to be used.

  use Test::More;
  use Test::Mojo;

  # Include application
  use FindBin;
  require "$FindBin::Bin/../echo.pl";

  # Test echo web service
  my $t = Test::Mojo->new;
  $t->websocket_ok('/echo')
    ->send_ok('Hello Mojo!')
    ->message_is('echo: Hello Mojo!')
    ->finish_ok;

  done_testing();

=head2 EventSource web service

EventSource is a special form of long-polling where you can directly send DOM
events from servers to clients. It is uni-directional, that means you will
have to use Ajax requests for sending data from clients to servers, the
advantage however is low infrastructure requirements, since it reuses the HTTP
protocol for transport.

  use Mojolicious::Lite;
  use Mojo::IOLoop;

  # Template with browser-side code
  get '/' => 'index';

  # EventSource for log messages
  get '/events' => sub {
    my $self = shift;

    # Increase inactivity timeout for connection a bit
    Mojo::IOLoop->stream($self->tx->connection)->timeout(300);

    # Change content type
    $self->res->headers->content_type('text/event-stream');

    # Subscribe to "message" event and forward "log" events to browser
    my $cb = $self->app->log->on(message => sub {
      my ($log, $level, @lines) = @_;
      $self->write("event:log\ndata: [$level] @lines\n\n");
    });

    # Unsubscribe from "message" event again once we are done
    $self->on(finish => sub {
      my $self = shift;
      $self->app->log->unsubscribe(message => $cb);
    });
  };

  app->start;
  __DATA__

  @@ index.html.ep
  <!DOCTYPE html>
  <html>
    <head><title>LiveLog</title></head>
    <body>
      <script>
        var events = new EventSource('<%= url_for 'events' %>');

        // Subscribe to "log" event
        events.addEventListener('log', function(event) {
          document.body.innerHTML += event.data + '<br/>';
        }, false);
      </script>
    </body>
  </html>

The event L<Mojo::Log/"message"> will be emitted for every new log message and
the event L<Mojo::Transaction/"finish"> right after the transaction has been
finished.

=head2 流式多段上传 

L<Mojolicious> 中包含了基于 L<Mojo::EventEmitter> 的一些非常复杂的事件系统，准备使用事件实现了几乎所有层的工作，可以用来结合处理 Web 开发中最麻烦的部分.

  use Mojolicious::Lite;
  use Scalar::Util 'weaken';

  # Emit "request" event early for requests that get upgraded to multipart
  hook after_build_tx => sub {
    my $tx = shift;
    weaken $tx;
    $tx->req->content->on(upgrade => sub { $tx->emit('request') });
  };

  # Upload form in DATA section
  get '/' => 'index';

  # Streaming multipart upload (invoked twice, due to early "request" event)
  post '/upload' => sub {
    my $self = shift;

    # First invocation, subscribe to "part" event to find the right one
    return $self->req->content->on(part => sub {
      my ($multi, $single) = @_;

      # Subscribe to "body" event of part to make sure we have all headers
      $single->on(body => sub {
        my $single = shift;

        # Make sure we have the right part and replace "read" event
        return unless $single->headers->content_disposition =~ /example/;
        $single->unsubscribe('read')->on(read => sub {
          my ($single, $chunk) = @_;

          # Log size of every chunk we receive
          $self->app->log->debug(length($chunk) . ' bytes uploaded.');
        });
      });
    }) unless $self->req->is_finished;

    # Second invocation, render response
    $self->render(text => 'Upload was successful.');
  };

  app->start;
  __DATA__

  @@ index.html.ep
  <!DOCTYPE html>
  <html>
    <head><title>Streaming multipart upload</title></head>
    <body>
      %= form_for upload => (enctype => 'multipart/form-data') => begin
        %= file_field 'example'
        %= submit_button 'Upload'
      % end
    </body>
  </html>

=head2 事件循环 

在内部的 L<Mojo::IOLoop> 的事件环可以使用多种不同的后端， 例如，安装了 L<EV>  就会自动的使用。也可以使用其它的也能正常工作.
Internally the L<Mojo::IOLoop> event loop can use multiple reactor backends, L<EV> for example will be automatically used if installed. Which in turn allows other event loops like L<IO::Async> to just work.

  use Mojolicious::Lite;
  use EV;
  use IO::Async::Loop::EV;
  use IO::Async::Timer::Absolute;

  my $loop = IO::Async::Loop::EV->new;

  # Wait 3 seconds before rendering a response
  get '/' => sub {
    my $self = shift;
    $loop->add(IO::Async::Timer::Absolute->new(
      time      => time + 3,
      on_expire => sub { $self->render(text => 'Delayed by 3 seconds!') }
    ));
  };

  app->start;

象使用 L<AnyEvent>.

  use Mojolicious::Lite;
  use EV;
  use AnyEvent;

  # Wait 3 seconds before rendering a response
  get '/' => sub {
    my $self = shift;
    my $w;
    $w = AE::timer 3, 0, sub {
      $self->render(text => 'Delayed by 3 seconds!');
      undef $w;
    };
  };

  app->start;

后端到底是使用的什么事件循环并不重要.

  use Mojo::UserAgent;
  use EV;
  use AnyEvent;

  # Search Twitter for "perl"
  my $cv = AE::cv;
  my $ua = Mojo::UserAgent->new;
  $ua->get('http://search.twitter.com/search.json?q=perl' => sub {
    my ($ua, $tx) = @_;
    $cv->send($tx->res->json('/results/0/text'));
  });
  say $cv->recv;

你也可以为你的内置 Web 服务器的应用来使用 L<AnyEvent>。

  use Mojolicious::Lite;
  use Mojo::Server::Daemon;
  use EV;
  use AnyEvent;

  # Normal action
  get '/' => {text => 'Hello World!'};

  # Connect application with web server and start accepting connections
  my $daemon
    = Mojo::Server::Daemon->new(app => app, listen => ['http://*:8080']);
  $daemon->start;

  # Let AnyEvent take control
  AE::cv->recv;

=head1 USER AGENT

这个 L<Mojolicious> 只是一个 web 框架.

=head2 Web 元素挖掘 (Web scraping)

从网站找到你喜欢的信息出来是一个很有意思的事情。 你可以使用原生的 HTML/XML 的解析器 L<Mojo::DOM>， 这个支持全部的 CSS 的 selectors 。

  use Mojo::UserAgent;

  # 打开 Web 站点 
  my $ua = Mojo::UserAgent->new;
  my $tx = $ua->get('mojolicio.us/perldoc');

  # 取出 title
  say 'Title: ', $tx->res->dom->at('head > title')->text;

  # 取出 head 
  $tx->res->dom('h1, h2, h3')->each(sub {
    say 'Heading: ', shift->all_text;
  });

  # Recurse through children manually to extract more than just text
  sub text_and_images {
    my $elements = shift;
    for my $e ($elements->each) {

      # Text before this element
      print $e->text_before(0);

      # Also include alternate text for images
      print $e->{alt} if $e->type eq 'img';

      # Text from children
      my $children = $e->children;
      $children->size ? text_and_images($children) : print $e->text(0);
    }

    # Text after last element
    print $elements->[-1]->text_after(0);
  }
  text_and_images($tx->res->dom->children);

特别是对于 L<Mojolicious> 应用的单元测试来讲，这是一个非常强大的工具.

=head2 JSON Web 服务 

现在很多的 web 服务都是基于 JSON 的数据交换格式。 这也是为什么 L<Mojolicious> 中有一个可能是最快的纯 Perl 来实现的 L<Mojo::JSON> 的原因。

  use Mojo::UserAgent;
  use Mojo::Util 'encode';

  # Fresh user agent
  my $ua = Mojo::UserAgent->new;

  # Fetch the latest news about Mojolicious from Twitter
  my $search = 'http://search.twitter.com/search.json?q=Mojolicious';
  for $tweet (@{$ua->get($search)->res->json->{results}}) {

    # Tweet text
    my $text = $tweet->{text};

    # Twitter user
    my $user = $tweet->{from_user};

    # Show both
    say encode('UTF-8', "$text --$user");
  }

=head2 基本的认证 

你直接可以增加用户和密码到你的 URL 中就好了.

  use Mojo::UserAgent;

  my $ua = Mojo::UserAgent->new;
  say $ua->get('https://sri:secret@mojolicio.us/hideout')->res->body;

=head2 修饰后续请求 

L<Mojo::UserAgent> can automatically follow redirects, the event L<Mojo::UserAgent/"start"> allows you direct access to each transaction right after they have been initialized and before a connection gets associated with them.
L<Mojo::UserAgent> 可以自动的 follow 重定向，在  L<Mojo::UserAgent/"start"> 的事件中你可以直接访问到每次初始化后的并在后端建立连接之前。

  use Mojo::UserAgent;

  # User agent following up to 10 redirects
  my $ua = Mojo::UserAgent->new(max_redirects => 10);

  # Add a witty header to every request
  $ua->on(start => sub {
    my ($ua, $tx) = @_;
    $tx->req->headers->header('X-Bender' => 'Bite my shiny metal ass!');
    say 'Request: ', $tx->req->url->clone->to_abs;
  });

  # Request that will most likely get redirected
  say 'Title: ', $ua->get('google.com')->res->dom->at('head > title')->text;

这个也可以工作在代理服务时的 C<CONNECT> 的请求上。

=head2 流响应 

大多的客户端浏览器都能接收流的响应，在 L<Mojo::UserAgent> 中也可以非常容易的使用它。

  use Mojo::UserAgent;

  # Build a normal transaction
  my $ua = Mojo::UserAgent->new;
  my $tx = $ua->build_tx(GET => 'http://mojolicio.us');

  # Replace "read" events to disable default content parser
  $tx->res->content->unsubscribe('read')->on(read => sub {
    my ($content, $chunk) = @_;
    say "Streaming: $chunk";
  });

  # Process transaction
  $ua->start($tx);

在 L<Mojo::Content/"read">  的事件会在每次 chunk 的数据到达时调用，每个 C<chunked> 的编码会被透明地处理，如果必要的话。

=head2 流请求 

发送流式的请求也一样很容易.

  use Mojo::UserAgent;

  # Build a normal transaction
  my $ua = Mojo::UserAgent->new;
  my $tx = $ua->build_tx(GET => 'http://mojolicio.us');

  # Prepare content
  my $content = 'Hello world!';
  $tx->req->headers->content_length(length $content);

  # Start writing directly with a drain callback
  my $drain;
  $drain = sub {
    my $req   = shift;
    my $chunk = substr $content, 0, 1, '';
    $drain    = undef unless length $content;
    $req->write($chunk, $drain);
  };
  $tx->req->$drain;

  # Process transaction
  $ua->start($tx);

在前一个块写真的写完后，会调用在 drain 回调使用 L<Mojo::Message/"write"> 的方法。

=head2 大文件下载 

当你使用 L<Mojo::UserAgent> 下载大文件时，你不需要担心内存的使用，因为它会自动的给每 C<250KB> 存成临时文件.

  use Mojo::UserAgent;

  # Lets fetch the latest Mojolicious tarball
  my $ua = Mojo::UserAgent->new(max_redirects => 5);
  my $tx = $ua->get('latest.mojolicio.us');
  $tx->res->content->asset->move_to('mojo.tar.gz');

为了保护避免过大的文件也有一个极限默认值 C<5MB>。你可以通过 C<MOJO_MAX_MESSAGE_SIZE> 的环境变量来调整。

  # Increase limit to 1GB
  $ENV{MOJO_MAX_MESSAGE_SIZE} = 1073741824;

=head2 大文件上传

上传一个大文件更容易.

  use Mojo::UserAgent;

  # Upload file via POST and "multipart/form-data"
  my $ua = Mojo::UserAgent->new;
  $ua->post_form('mojolicio.us/upload',
    {image => {file => '/home/sri/hello.png'}});

当然一样，你还是不必担心内存的使用，因为这个也是直接流式传送这个文件。

  use Mojo::UserAgent;

  # Upload file via PUT
  my $ua     = Mojo::UserAgent->new;
  my $asset  = Mojo::Asset::File->new(path => '/home/sri/hello.png');
  my $tx     = $ua->build_tx(PUT => 'mojolicio.us/upload');
  $tx->req->content->asset($asset);
  $ua->start($tx);

=head2 非阻塞 

这个 L<Mojo::UserAgent> 从底层开始就是设计成非阻塞的，整个阻塞的 API 仅仅是一个简单方便的包装。特别是对于高延迟的任务，如网络抓取，这种功能非常有用，因为可以使你同时并行很多连接。

  use Mojo::UserAgent;
  use Mojo::IOLoop;

  # Parallel non-blocking requests
  my $ua = Mojo::UserAgent->new;
  $ua->get('http://mojolicio.us' => sub {
    my ($ua, $tx) = @_;
    ...
  });
  $ua->get('http://mojolicio.us/perldoc' => sub {
    my ($ua, $tx) = @_;
    ...
  });

  # Start event loop if necessary
  Mojo::IOLoop->start unless Mojo::IOLoop->is_running;

您可以完全控制的 L<Mojo::IOLoop> 的事件循环。

=head2 并行阻塞请求 

你可以模拟阻塞的行为使用 L<Mojo::IOLoop>  的 delay 来同步多个非阻塞的请求。不过你需要知道，多个任务结束的顺序是随机的.

  use Mojo::UserAgent;
  use Mojo::IOLoop;

  # Synchronize non-blocking requests and capture result
  my $ua    = Mojo::UserAgent->new;
  my $delay = Mojo::IOLoop->delay;
  $ua->get('http://mojolicio.us'         => $delay->begin);
  $ua->get('http://mojolicio.us/perldoc' => $delay->begin);
  my ($tx, $tx2) = $delay->wait;

这个 L<Mojo::IOLoop::Delay/"finish"> 的事件不但在  L<Mojolicious>  的应用内可以使用，也能够独立工作。

  use Mojo::UserAgent;
  use Mojo::IOLoop;

  # Synchronize non-blocking requests portably
  my $ua    = Mojo::UserAgent->new;
  my $delay = Mojo::IOLoop->delay(sub {
    my ($delay, $tx, $tx2) = @_;
    ...
  });
  $ua->get('http://mojolicio.us'         => $delay->begin);
  $ua->get('http://mojolicio.us/perldoc' => $delay->begin);
  $delay->wait unless Mojo::IOLoop->is_running;

=head2 命令行 

在使用命令行检查时，不知道你们是不是很反感很大的 HTML 文件。得益于  C<mojo get> 这个命令可以帮助我们改变这些。你只需要随意的使用一下 CSS 的选择器  L<Mojo::DOM>  和 JOSNP 的  L<Mojo::JSON::Pointer> 就能搞定.

  $ mojo get http://mojolicio.us 'head > title'

怎么样列出全部属性的 id?

  $ mojo get http://mojolicio.us '*' attr id

或文字标题标签的所有内容?

  $ mojo get http://mojolicio.us 'h1, h2, h3' text

也许只是文本的第三个标题?

  $ mojo get http://mojolicio.us 'h1, h2, h3' 3 text

你还可以从嵌套的子元素提取所有的文字?

  $ mojo get http://mojolicio.us '#mojobar' all

发送定制的请求.

  $ mojo get -M POST -c 'Hello!' http://mojolicio.us
  $ mojo get -H 'X-Bender: Bite my shiny metal ass!' http://google.com

您可以跟随重定向和查看 header 的所有消息。

  $ mojo get -r -v http://reddit.com 'head > title'

从 JSON 的数据结构中提取信息.

  $ mojo get http://search.twitter.com/search.json /error

这可以是一个非常好的工具，用于测试您的应用程序

  $ ./myapp.pl get /welcome 'head > title'

=head2 单行 

为了快速的 hacks 和测试， L<ojo> 的单行也是一个不错的选择.

  $ perl -Mojo -E 'say g("mojolicio.us")->dom->html->head->title->text'

=head1 HACKS

有一些不错的功能，虽然不一定经常使用，但可能用时会非常不错.

=head2 增加命令到 Mojolicious

你现在可能使用了很多 L<Mojolicious::Commands> 原生的命令，对于新增加一个命令，也非常的方便.

  package Mojolicious::Command::spy;
  use Mojo::Base 'Mojolicious::Command';

  has description => "Spy on application.\n";
  has usage       => "usage: $0 spy [TARGET]\n";

  sub run {
    my ($self, $target) = @_;

    # Leak secret passphrase
    if ($target eq 'secret') {
      my $secret = $self->app->secret;
      say qq{The secret of this application is "$secret".};
    }
  }

  1;

在  L<Mojolicious::Command> 中有很多有用的方法和属性，当然你可以重载它们。

  $ mojo spy secret
  The secret of this application is "Mojolicious::Lite".

  $ ./myapp.pl spy secret
  The secret of this application is "secr3t".

在你的应用中加入新的特别的命令，你还可以指定不同的名字空间.

  # Application
  package MyApp;
  use Mojo::Base 'Mojolicious';

  sub startup {
    my $self = shift;

    # Add another namespace to load commands from
    push @{$self->commands->namespaces}, 'MyApp::Command';
  }

  1;

=head2 针对您的应用程序来运行代码 

没有想过对 L<Mojolicious> 的应用程序使用一个快速的单行来测试? 得益于的 C<eval> 命令，你可以方便的做到这一点，直接通过 C<app> 来访问应用程序对象本身。

  $ mojo generate lite_app
  $ ./myapp.pl eval 'say for @{app->static->paths}'

使用 C<verbose> 选择会让 print 和 return 的值直接打印到 C<STDOUT>.

  $ ./myapp.pl eval -v 'app->static->paths->[0]'

=head2 应用程序安装 

你有没有想过使用 CPAN 来安装你的  L<Mojolicious> 的应用，这个比实际的想象还要容易.

  $ mojo generate app
  $ cd my_mojolicious_app
  $ mv public lib/MyMojoliciousApp/
  $ mv templates lib/MyMojoliciousApp/

这个关键是要给 C<public>  和 C<templates> 的目录移到能够自动安装的模块的地方.

  # Application
  package MyMojoliciousApp;
  use Mojo::Base 'Mojolicious';

  use File::Basename 'dirname';
  use File::Spec::Functions 'catdir';

  # Every CPAN module needs a version
  our $VERSION = '1.0';

  sub startup {
    my $self = shift;

    # Switch to installable home directory
    $self->home->parse(catdir(dirname(__FILE__), 'MyMojoliciousApp'));

    # Switch to installable "public" directory
    $self->static->paths->[0] = $self->home->rel_dir('public');

    # Switch to installable "templates" directory
    $self->renderer->paths->[0] = $self->home->rel_dir('templates');

    $self->plugin('PODRenderer');

    my $r = $self->routes;
    $r->get('/welcome')->to('example#welcome');
  }

  1;

这就是所有啦，你现在可以象任何其它的 CPAN 模块一样给你的程序打包.

  $ ./script/my_mojolicious_app generate makefile
  $ perl Makefile.PL
  $ make test
  $ make manifest
  $ make dist

然后使用你的 C<PAUSE> 的帐号(通过 L<http://pause.perl.org> 注册)来上传.

  $ mojo cpanify -u USER -p PASS MyMojoliciousApp-0.01.tar.gz

=head2 Hello World

每个字都很重要，你可以使用最少的字来写一个基于 L<Mojolicious::Lite> 的 C<Hello World> 的应用.

  use Mojolicious::Lite;
  any {text => 'Hello World!'};
  app->start;

这个程序，没有模式路径选择，所以会使用默认的 C</> 然后自动的调用 stash 中的值来生成一个响应.

=head2 单行的 Hello World 应用

这个 C<Hello World>  的例子也可以使用 L<ojo> 的单行实现.

  $ perl -Mojo -E 'a({text => "Hello World!"})->start' daemon

这时你还是可以使用全部的 L<Mojolicious::Commands> 的命令的.

  $ perl -Mojo -E 'a({text => "Hello World!"})->start' get -v /

=head1 更多

你可以看看 L<Mojolicious::Guides> 和 L<Mojolicious wiki|http://github.com/kraih/mojo/wiki> 来了解更多的东西.

=cut
