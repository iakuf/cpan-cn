package pp; # Now people can say "install pp" in the CPAN shell.
use 5.006;
use strict;
use warnings;
use PAR::Packer ();

# This line is here so CPAN.pm can parse a $VERSION from us...
our $VERSION = '0.992';

# ...but we read our $VERSION again from PAR::Packer in case we forgot to update
# the $VERSION above during release engineering.
$VERSION = $PAR::Packer::VERSION;

use PAR ();
use Module::ScanDeps ();
use App::Packer::PAR ();
use Getopt::ArgvFile default=>1;
use Getopt::Long qw(:config no_ignore_case);


sub go {
    my $class = shift;

    unshift(@ARGV, split / +/, $ENV{PP_OPTS}) if $ENV{PP_OPTS};
    
    my %opt;
    GetOptions( \%opt, PAR::Packer->options, 'h|help', 'V|version' );
    help() if $opt{h};
    version() if $opt{V};
    
    local $Module::ScanDeps::ScanFileRE = qr/./;

    App::Packer::PAR->new(
        frontend    => 'Module::ScanDeps',
        backend     => 'PAR::Packer',
        frontopts   => \%opt,
        backopts    => \%opt,
        args        => \@ARGV,
    )->go;

    return 1;
}

sub help {
    print "PAR Packager, version $VERSION (PAR version $PAR::VERSION)\n\n";
    {
        no warnings;
        exec "perldoc $0";
        exec "pod2text $0";
    }
    version();
}

sub version {
    print << ".";
PAR Packager, version $VERSION (PAR version $PAR::VERSION)
Copyright 2002-2009 by Audrey Tang <cpan\@audreyt.org>

Neither this program nor the associated "parl" program impose any
licensing restrictions on files generated by their execution, in
accordance with the 8th article of the Artistic License:

        "Aggregation of this Package with a commercial distribution is
        always permitted provided that the use of this Package is embedded;
        that is, when no overt attempt is made to make this Package's
        interfaces visible to the end user of the commercial distribution.
        Such use shall not be construed as a distribution of this Package."

Therefore, you are absolutely free to place any license on the resulting
executable, as long as the packed 3rd-party libraries are also available
under the Artistic License.

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.  There is NO warranty; not even for
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

.
    exit;
}

__END__

=pod

=encoding utf-8

=head1 文档

pp - PAR Packager

=head1 SYNOPSIS

B<pp> S<[ B<-ABCEFILMPTSVXacdefghilmnoprsvxz> ]> S<[ I<parfile> | I<scriptfile> ]>...

=head1 EXAMPLES

注意: 当运行在 Microsoft Windows 时，这个 F<a.out> 会替换成 F<a.exe> 

    % pp hello.pl               # Pack 'hello.pl' into executable 'a.out'
    % pp -o hello hello.pl      # Pack 'hello.pl' into executable 'hello'
                                # (or 'hello.exe' on Win32)

    % pp -o foo foo.pl bar.pl   # 给 'foo.pl' 和 'bar.pl' 封装成 'foo' 一个文件
    % ./foo                     # 运行 'foo' 里面的 'foo.pl' 
    % mv foo bar; ./bar         # 运行 'foo' 里面的 'bar.pl' 
    % mv bar baz; ./baz         # Error: Can't open perl script "baz" 这样就出错了，因为包中找不到 baz

    % pp -p file                # Creates a PAR file, 'a.par'
    % pp -o hello a.par         # Pack 'a.par' to executable 'hello'
    % pp -S -o hello file       # Combine the two steps above

    % pp -p -o out.par file     # Creates 'out.par' from 'file'
    % pp -B -p -o out.par file  # same as above, but bundles core modules
                                # and removes any local paths from @INC
    % pp -P -o out.pl file      # Creates 'out.pl' from 'file'
    % pp -B -p -o out.pl file   # same as above, but bundles core modules
                                # and removes any local paths from @INC
                                # (-B is assumed when making executables)

    % pp -e "print 123"         # Pack a one-liner into 'a.out'
    % pp -p -e "print 123"      # Creates a PAR file 'a.par'
    % pp -P -e "print 123"      # Creates a perl script 'a.pl'

    % pp -c hello               # Check dependencies from "perl -c hello"
    % pp -x hello               # Check dependencies from "perl hello"
    % pp -n -x hello            # same as above, but skips static scanning

    % pp -I /foo hello          # Extra include paths
    % pp -M Foo::Bar hello      # Extra modules in the include path
    % pp -M abbrev.pl hello     # Extra libraries in the include path
    % pp -X Foo::Bar hello      # Exclude modules
    % pp -a data.txt hello      # Additional data files

    % pp -r hello               # Pack 'hello' into 'a.out', runs 'a.out'
    % pp -r hello a b c         # Pack 'hello' into 'a.out', runs 'a.out'
                                # with arguments 'a b c'

    % pp hello --log=c          # Pack 'hello' into 'a.out', logs
                                # messages into 'c'

    # Pack 'hello' into a console-less 'out.exe' with icon (Win32 only)
    % pp --gui --icon hello.ico -o out.exe hello

    % pp @file hello.pl         # Pack 'hello.pl' but read _additional_
                                # options from file 'file'

=head1 描述

F<pp> 是用来从 Perl 程序创建独立的可执行文件，靠 L<PAR> 提供的压缩封装的机制，并由  L<Module::ScanDeps> 来进行模块依赖的检测。 源文件被逐字压缩的。

你可以会认为 F<pp> 和 F<perlcc>  会很麻烦.

这个也有一个 GUI 的接口叫 F<tkpp> 的命令.

它没有提供 F<perlcc> 所提供的编译步骤来加速程序 (不过，我们可以看看 B<-f> 的字节编译选项和源代码隐藏技术)， but makes up for it with better reliability, smaller executable size, and full retrieval of original source code.

当输入是一个指定的单个程序，这个生成的可执行程序会和这个程序一样。然而，当给了多个程序给打成同一个包时，生成的可执行文件执行和 C<$0> 相同的名字的程序 (即调用它的文件名)
如果包中没文件匹配上，会出现 die 的错误 C<Can't open perl script "$0">.

=head1 选项

所有的选项都有一个 I<短命令> 和一个 I<长> 命令。如下面的例子中，作用基本是相等的。

    % pp -o output.exe input.pl
    % pp --output output.exe input.pl
    % pp --output=output.exe input.pl

由于命令行有可以变得足够长，以达到一些 shell 的限制。I<pp> 可以从一个或多个文本文件中读取一些选项。基本的使用方法是传一个 (@) 符号的参数给它，这些参数是表示从文件中读取的选项。这个 C<@file> 和普通的选项可以混合使用。是使用的 L<Getopt::ArgvFile> 模块实现的，所以你可以看看详细的相关的文档。

=over 4

=item B<-a>, B<--addfile>=I<FILE>|I<DIR>

添加一个额外的文件放入包中。如果该文件是一个目录，递归添加该目录内的所有文件，链接会使用实际的文件。

默认，这些文件是直接放包中 C</> 的路径里面，并使用原来的名字。如果你的 C<;> 后面的文件名会被覆盖掉前面的。象下面这个.

    % pp -a "old_filename.txt;new_filename.txt"
    % pp -a "old_dirname;new_dirname"

您可以指定使用 C<-a> 来指定多次.

=item B<-A>, B<--addlist>=I<FILE>

从 I<FILE> 中读取文件或目录的名字，并添加到包中。 在 I<FILE> 中的每行会当成上面 B<-a> 的参数。

一样，你也可以指定使用 C<-A> 多次.

=item B<-B>, B<--bundle>

在生成的包中绑定核心模块。 这个选项默认是启用的，除非指定了 C<-p> 或者 C<-P>。

自从 PAR 的 0.953 开始，在运行自包含的脚本时，会从 C<@INC> 中查找到的模块路径上去掉了所有的本地的路径信息。

=item B<-C>, B<--clean>

在运行这个应用程序的时候，从临时文件目录中删除提取出来的文件。默认的情况下，这些文件会缓存在临时目录中，这会使得你的程序在下一次启动更加快。

=item B<-c>, B<--compile>

在运行 C<perl -c inputfile> 时来确认额外的运行时的依赖关系-好象是指编译阶段确认.

=item B<-cd>, B<--cachedeps>=I<FILE>

使用 I<FILE>  来缓存检测到的依赖，只要不是第一次创建这个，就能加快随后运行的扫描的过程。

=item B<-d>, B<--dependent>

去掉 Perl 解释器的拷贝，减少可执行文件的大小。这种方式构建的可执行文件，需要一个独立的 F<perl5x.dll>，或 F<libperl.so> 才能正常。此选项仅适用 perl built 成一个共享库。

=item B<-e>, B<--eval>=I<STRING>

由一个单行成生包，和  C<perl -e '...'> 一样。

=item B<-E>, B<--evalfeature>=I<STRING>

行为就类似于 C<-e>, 不同的在于，在 Perl 5.10 或者更高的版本中，它会隐式使所有的可选功能（在主要编译单元中）L<feature>。

=item B<-x>, B<--execute>

运行 C<perl inputfile> 会在确定产生额外的运行时依赖。

=item B<-X>, B<--exclude>=I<MODULE>

从包中和依赖摸索路径中排除指定的模块。 如果给的是文件是 zip 或 par 或 par 的执行文件，全部的这些文件会被排除(不算 MANIFEST, META.yml 和 script/*)。输入的文件在运行时会要使用 "use" 这些文件。

=item B<-f>, B<--filter>=I<FILTER>

使用 L<PAR::Filter> 的子类来做脚本滤镜。你也可以指定多个滤镜。

如果你想防止别人读你的源代码，你可以这样做:

    % pp -f Bleach source.pl

如果你想更高级别的隐藏你的源代码，你可以看看 Steve Hay's 写的  L<PAR::Filter::Crypto> 模块。不过你需要确保你明白 Filter::Crypto 相关的内容和注意事项.

=item B<-g>, B<--gui>

Build an executable that does not have a console window. This option is ignored on non-MSWin32 platforms or when C<-p> is specified.

=item B<-h>, B<--help>

Show basic usage information.

=item B<-i>, B<--icon>=I<FILE>

Specify an icon file (in F<.ico>, F<.exe> or F<.dll> format) for the
executable. This option is ignored on non-MSWin32 platforms or when C<-p>
is specified.

=item B<-N>, B<--info>=I<KEY=VAL>

Add additional information for the packed file, both in C<META.yml>
and in the executable header (if applicable).  The name/value pair is
joined by C<=>.  You may specify C<-N> multiple times, or use C<;> to
link several pairs.

For Win32 executables, these special C<KEY> names are recognized:

    Comments        CompanyName     FileDescription FileVersion
    InternalName    LegalCopyright  LegalTrademarks OriginalFilename
    ProductName     ProductVersion

=item B<-I>, B<--lib>=I<DIR>

Add the given directory to the perl library file search path.  May
be specified multiple times.

=item B<-l>, B<--link>=I<FILE>|I<LIBRARY>

Add the given shared library (a.k.a. shared object or DLL) into the
packed file.  Also accepts names under library paths; i.e.
C<-l ncurses> means the same thing as C<-l libncurses.so> or
C<-l /usr/local/lib/libncurses.so> in most Unixes.  May be specified
multiple times.

=item B<-L>, B<--log>=I<FILE>

Log the output of packaging to a file rather than to stdout.

=item B<-F>, B<--modfilter>=I<FILTER[=REGEX]>,

Filter included perl module(s) with a L<PAR::Filter> subclass.
You may specify multiple such filters. 

By default, the I<PodStrip> filter is applied.  In case
that causes trouble, you can turn this off by setting the
environment variable C<PAR_VERBATIM> to C<1>.

Since PAR 0.958, you can use an optional regular expression (I<REGEX> above)
to select the files in the archive which should be filtered. Example:

  pp -o foo.exe -F Bleach=warnings\.pm$ foo.pl

This creates a binary executable F<foo.exe> from F<foo.pl> packaging all files
as usual except for files ending in C<warnings.pm> which are filtered with
L<PAR::Filter::Bleach>.

=item B<-M>, B<--module>=I<MODULE>

Add the specified module into the package, along with its dependencies.
Also accepts filenames relative to the C<@INC> path; i.e. C<-M
Module::ScanDeps> means the same thing as C<-M Module/ScanDeps.pm>.

If I<MODULE> has an extension that is not C<.pm>/C<.ix>/C<.al>, it will not
be scanned for dependencies, and will be placed under C</> instead of
C</lib/> inside the PAR file.  This use is deprecated -- consider using
the B<-a> option instead.

You may specify C<-M> multiple times.

=item B<-m>, B<--multiarch>

Build a multi-architecture PAR file.  Implies B<-p>.

=item B<-n>, B<--noscan>

Skip the default static scanning altogether, using run-time
dependencies from B<-c> or B<-x> exclusively.

=item B<-o>, B<--output>=I<FILE>

File name for the final packaged executable.

=item B<-p>, B<--par>

Create PAR archives only; do not package to a standalone binary.

=item B<-P>, B<--perlscript>

Create stand-alone perl script; do not package to a standalone binary.

=item B<-r>, B<--run>

Run the resulting packaged script after packaging it.

=item B<--reusable>

B<EXPERIMENTAL>

Make the packaged executable reusable for running arbitrary, external
Perl scripts as if they were part of the package:

  pp -o myapp --reusable someapp.pl
  ./myapp --par-options --reuse otherapp.pl

The second line will run F<otherapp.pl> instead of F<someapp.pl>.

=item B<-S>, B<--save>

Do not delete generated PAR file after packaging.

=item B<-s>, B<--sign>

Cryptographically sign the generated PAR or binary file using
L<Module::Signature>.

=item B<-T>, B<--tempcache>

Set the program unique part of the cache directory name that is used
if the program is run without -C. If not set, a hash of the executable
is used.

When the program is run, its contents are extracted to a temporary
directory.  On Unix systems, this is commonly
F</tmp/par-USERNAME/cache-XXXXXXX>.  F<USERNAME> is replaced by the
user running the program, and F<XXXXXXX> is either a hash of the
executable or the value passed to the C<-T> or C<--tempcache> switch.

=item B<-v>, B<--verbose>[=I<NUMBER>]

Increase verbosity of output; I<NUMBER> is an integer from C<1> to C<3>,
C<3> being the most verbose.  Defaults to C<1> if specified without an
argument.  Alternatively, B<-vv> sets verbose level to C<2>, and B<-vvv>
sets it to C<3>.

=item B<-V>, B<--version>

Display the version number and copyrights of this program.

=item B<-z>, B<--compress>=I<NUMBER>

Set zip compression level; I<NUMBER> is an integer from C<0> to C<9>,
C<0> = no compression, C<9> = max compression.  Defaults to C<6> if
B<-z> is not used.

=back

=head1 ENVIRONMENT

=over 4

=item PP_OPTS

Command-line options (switches).  Switches in this variable are taken
as if they were on every F<pp> command line.

=back

=head1 NOTES

Here are some recipes showing how to utilize F<pp> to bundle
F<source.pl> with all its dependencies, on target machines with
different expected settings:

=over 4

=item Stone-alone setup:

To make a stand-alone executable, suitable for running on a
machine that doesn't have perl installed:


    % pp -o packed.exe source.pl        # makes packed.exe
    # Now, deploy 'packed.exe' to target machine...
    $ packed.exe                        # run it

=item Perl interpreter only, without core modules:

To make a packed .pl file including core modules, suitable
for running on a machine that has a perl interpreter, but where
you want to be sure of the versions of the core modules that
your program uses:

    % pp -B -P -o packed.pl source.pl   # makes packed.pl
    # Now, deploy 'packed.pl' to target machine...
    $ perl packed.pl                    # run it

=item Perl with core modules installed:

To make a packed .pl file without core modules, relying on the target
machine's perl interpreter and its core libraries.  This produces
a significantly smaller file than the previous version:

    % pp -P -o packed.pl source.pl      # makes packed.pl
    # Now, deploy 'packed.pl' to target machine...
    $ perl packed.pl                    # run it

=item Perl with PAR.pm and its dependencies installed:

Make a separate archive and executable that uses the archive. This
relies upon the perl interpreter and libraries on the target machine.

    % pp -p source.pl                   # makes source.par
    % echo "use PAR 'source.par';" > packed.pl;
    % cat source.pl >> packed.pl;       # makes packed.pl
    # Now, deploy 'source.par' and 'packed.pl' to target machine...
    $ perl packed.pl                    # run it, perl + core modules required

=back

Note that even if your perl was built with a shared library, the
'Stand-alone executable' above will I<not> need a separate F<perl5x.dll>
or F<libperl.so> to function correctly.  But even in this case, the
underlying system libraries such as I<libc> must be compatible between
the host and target machines.  Use C<--dependent> if you
are willing to ship the shared library with the application, which
can significantly reduce the executable size.

=head1 SEE ALSO

L<tkpp>, L<par.pl>, L<parl>, L<perlcc>

L<PAR>, L<PAR::Packer>, L<Module::ScanDeps>

L<Getopt::Long>, L<Getopt::ArgvFile>

=head1 ACKNOWLEDGMENTS

Simon Cozens, Tom Christiansen and Edward Peschko for writing
F<perlcc>; this program try to mimic its interface as close
as possible, and copied liberally from their code.

Jan Dubois for writing the F<exetype.pl> utility, which has been
partially adapted into the C<-g> flag.

Mattia Barbon for providing the C<myldr> binary loader code.

Jeff Goff for suggesting the name C<pp>.

=head1 AUTHORS

Audrey Tang E<lt>cpan@audreyt.orgE<gt>,
Steffen Mueller E<lt>smueller@cpan.orgE<gt>

L<http://par.perl.org/> is the official PAR website.  You can write
to the mailing list at E<lt>par@perl.orgE<gt>, or send an empty mail to
E<lt>par-subscribe@perl.orgE<gt> to participate in the discussion.

Please submit bug reports to E<lt>bug-par@rt.cpan.orgE<gt>.

=head1 COPYRIGHT

Copyright 2002-2009 by Audrey Tang
E<lt>cpan@audreyt.orgE<gt>.

Neither this program nor the associated L<parl> program impose any
licensing restrictions on files generated by their execution, in
accordance with the 8th article of the Artistic License:

    "Aggregation of this Package with a commercial distribution is
    always permitted provided that the use of this Package is embedded;
    that is, when no overt attempt is made to make this Package's
    interfaces visible to the end user of the commercial distribution.
    Such use shall not be construed as a distribution of this Package."

Therefore, you are absolutely free to place any license on the resulting
executable, as long as the packed 3rd-party libraries are also available
under the Artistic License.

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

See L<http://www.perl.com/perl/misc/Artistic.html>

=cut
